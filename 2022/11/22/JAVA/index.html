
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>JAVA - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="yyl,"> 
    <meta name="description" content="一.第一段程序12345public class Hello&amp;#123;                            //文件名字要与类名相同    public static void ,"> 
    <meta name="author" content="yyl"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="JAVA - Hexo"/>
    <meta name="twitter:description" content="一.第一段程序12345public class Hello&amp;#123;                            //文件名字要与类名相同    public static void ,"/>
    
    
    
    
    <meta property="og:site_name" content="Hexo"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="JAVA - Hexo"/>
    <meta property="og:description" content="一.第一段程序12345public class Hello&amp;#123;                            //文件名字要与类名相同    public static void ,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 5.4.2"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">JAVA</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">JAVA</h1>
        <div class="stuff">
            <span>十一月 22, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li></ul>


        </div>
        <div class="content markdown">
            <h3 id="一-第一段程序"><a href="#一-第一段程序" class="headerlink" title="一.第一段程序"></a>一.第一段程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;                            <span class="comment">//文件名字要与类名相同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二-变量"><a href="#二-变量" class="headerlink" title="二.变量"></a>二.变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">num</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">byte</span> num2=<span class="number">35</span>;      <span class="comment">//字节型      1个字节   -128~127</span></span><br><span class="line">        <span class="type">short</span> num3=<span class="number">50</span>;     <span class="comment">//短整型      2个字节   -32768~32767</span></span><br><span class="line">        <span class="type">int</span> num1=<span class="number">10</span>;       <span class="comment">//整形        4个字节   -2^31~2^31-1</span></span><br><span class="line">        <span class="type">long</span> num4=<span class="number">3000000L</span>;<span class="comment">//长整型      8个字节   -2^63~2^63-1      后面要加L</span></span><br><span class="line">        <span class="type">float</span> numm5=<span class="number">2.5F</span>;  <span class="comment">//单精度浮点数  4个字节   1.4013E-45~3.4028E+38  后边要加F</span></span><br><span class="line">        <span class="type">double</span> num6=<span class="number">1.2</span>;   <span class="comment">//双精度浮点型   8个字节  4.9E-324~1.7977E+308</span></span><br><span class="line">        <span class="type">char</span> zifu1=<span class="string">&#x27;S&#x27;</span>;    <span class="comment">//字符型        2个字节  0~65535</span></span><br><span class="line">        <span class="type">boolean</span> var1=<span class="literal">true</span>; <span class="comment">//布尔类型      一个字节  true false</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-数据转换"><a href="#三-数据转换" class="headerlink" title="三.数据转换"></a>三.数据转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">num</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//自动转换:</span></span><br><span class="line">        <span class="type">long</span> num1=<span class="number">100</span>;     <span class="comment">//右边int 类型比左边数据范围小.自动转为long</span></span><br><span class="line">        <span class="type">double</span> num2=<span class="number">2.5F</span>;  <span class="comment">//右边float 类型比左边数据范围小.自动转为double</span></span><br><span class="line">        <span class="type">float</span> num3=<span class="number">30L</span> ;   <span class="comment">//右边long 类型比左边数据范围小.自动转为float</span></span><br><span class="line">        <span class="comment">//强制转换:</span></span><br><span class="line">        <span class="type">int</span> num=(<span class="type">int</span>) <span class="number">100L</span>;<span class="comment">//强制转换</span></span><br><span class="line">        a+=<span class="number">2</span>               <span class="comment">//a=a+2</span></span><br><span class="line">        a&gt;b ? a:b          <span class="comment">//若前边为真则取a;否则取b</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四-方法的定义与调用"><a href="#四-方法的定义与调用" class="headerlink" title="四.方法的定义与调用"></a>四.方法的定义与调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">four</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        printf();                           <span class="comment">//方法调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printf</span><span class="params">()</span>&#123;            <span class="comment">//方法定义</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;    <span class="comment">//返回int类型</span></span><br><span class="line">        <span class="type">int</span> sum=a+b;</span><br><span class="line">        <span class="keyword">return</span> sum;                         <span class="comment">//返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span> <span class="title function_">sum</span><span class="params">(<span class="type">byte</span> a,<span class="type">byte</span> b)</span>&#123; <span class="comment">//函数重载   只和名字和参数相同 要求名字相同但参数不同(数量,类型等)</span></span><br><span class="line">        <span class="type">byte</span> sum=(<span class="type">byte</span>)(a+b);</span><br><span class="line">        <span class="keyword">return</span> sum; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五-选择语句"><a href="#五-选择语句" class="headerlink" title="五.选择语句"></a>五.选择语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ifelse</span>&#123;                            <span class="comment">//文件名字要与类名相同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">//if:</span></span><br><span class="line">    <span class="keyword">if</span>()                     <span class="comment">//若满足条件则执行后面的语句</span></span><br><span class="line">    &#123;&#125;                 </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>()</span><br><span class="line">    &#123;&#125;                       <span class="comment">//若满足条件则执行后面的语句</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">     <span class="comment">//switch:</span></span><br><span class="line">     <span class="keyword">switch</span>(<span class="number">5</span>)&#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六-循环语句"><a href="#六-循环语句" class="headerlink" title="六.循环语句"></a>六.循环语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ifelse</span>&#123;                          </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">//while:</span></span><br><span class="line">    <span class="type">int</span> val=<span class="number">0</span>,nums=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(++val&lt;=<span class="number">10</span>)           <span class="comment">//循环十次</span></span><br><span class="line">    &#123;</span><br><span class="line">        nums+=val;             <span class="comment">// nums = nums + val;</span></span><br><span class="line">        <span class="keyword">if</span>(val==<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">break</span>;             <span class="comment">//break 跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(val==<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">continue</span>;         <span class="comment">//continue 结束本次循环,开始下次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(std::cin&gt;&gt;val)</span><br><span class="line">        nums+=val;            <span class="comment">//循环一直进行直达遇到 文件结束符或者错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for循环</span></span><br><span class="line">    <span class="type">int</span> nums=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> val= <span class="number">1</span>;val&lt;=<span class="number">10</span>;++val)</span><br><span class="line">        nums+=val;</span><br><span class="line">    <span class="comment">//do...while:</span></span><br><span class="line">    <span class="keyword">do</span>&#123;&#125;<span class="keyword">while</span>()               <span class="comment">//至少进行一次循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七-数组"><a href="#七-数组" class="headerlink" title="七.数组"></a>七.数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">array</span>&#123;</span><br><span class="line">    pubiic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> [] array1=<span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">100</span>];           <span class="comment">//动态初始化存一百个int 的数组</span></span><br><span class="line">        <span class="type">int</span> [] array2=<span class="keyword">new</span> <span class="title class_">int</span> [] &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;    <span class="comment">//静态初始化</span></span><br><span class="line">        <span class="type">int</span> [] array3=&#123;<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;               <span class="comment">//静态初始化省略</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">let</span> <span class="operator">=</span>array.length;                 <span class="comment">//数组长度</span></span><br><span class="line">        classname [] array=<span class="keyword">new</span> <span class="title class_">classname</span>[<span class="number">3</span>];   <span class="comment">//对象数组</span></span><br><span class="line">        <span class="type">classname</span> <span class="variable">one</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">classname</span>();</span><br><span class="line">        array[<span class="number">0</span>]=one;                          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="八-动态数组"><a href="#八-动态数组" class="headerlink" title="八.动态数组"></a>八.动态数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&#123;</span><br><span class="line">    pubiic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	ArrayList&lt;string&gt; list =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();       <span class="comment">//构造动态数组</span></span><br><span class="line">    list.add(<span class="string">&quot;三天后&quot;</span>);                               <span class="comment">//从最后面插入元素</span></span><br><span class="line">        基本类型      包装类</span><br><span class="line">          <span class="type">byte</span>     Byte</span><br><span class="line">          <span class="type">short</span>    Short</span><br><span class="line">          <span class="type">int</span>       Integer</span><br><span class="line">          <span class="type">long</span>      Long</span><br><span class="line">          <span class="type">float</span>     Float</span><br><span class="line">          <span class="type">double</span>    Double</span><br><span class="line">          <span class="type">char</span>       Character</span><br><span class="line">          <span class="type">boolean</span>    Boolean </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="九-字符串"><a href="#九-字符串" class="headerlink" title="九.字符串"></a>九.字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">string</span>&#123;</span><br><span class="line">    pubiic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     1.字符串不可变</span></span><br><span class="line"><span class="comment">     2.字符串可共享</span></span><br><span class="line"><span class="comment">     3.字符串表现为char []数组,但实际上底层原理是byte[] 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     构造方法</span></span><br><span class="line"><span class="comment">     1.public String()                        //构造空字符串</span></span><br><span class="line"><span class="comment">     2.public String(char [] array)           //使用字符数组创建,地址指向字符数组再指向byte[]</span></span><br><span class="line"><span class="comment">     3.public String(byte [] array)</span></span><br><span class="line"><span class="comment">     4.string char=&quot;afhjg&quot;                    //地址指向字符串常量池,再指向字符数组再指向byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     使用方法</span></span><br><span class="line"><span class="comment">     1.public boolean equals(object obj)      //比较</span></span><br><span class="line"><span class="comment">     2.public int Length()                    //获取长度</span></span><br><span class="line"><span class="comment">     3.public String concat(String str)       //拼接字符串</span></span><br><span class="line"><span class="comment">     4.public char charAt(int index)          //获取指定位置字符串</span></span><br><span class="line"><span class="comment">     5.public int indexOf(String str)         //查找子串出现位置</span></span><br><span class="line"><span class="comment">     6.public String substring(int index)     //从参数位置开始截取到尾部</span></span><br><span class="line"><span class="comment">     7.public String substring(int begin,int end)//截取范围内字符串,前闭后开</span></span><br><span class="line"><span class="comment">     8.public char[] toCharArray()             //转换成Char数组</span></span><br><span class="line"><span class="comment">     9.public byte getBytes()                  //获取底层byte数组</span></span><br><span class="line"><span class="comment">     10.public String replace(CharSequencr oldString,CharSequencr NewString)//替换</span></span><br><span class="line"><span class="comment">     11.public String[] split(String reget)    //按指定参数分割字符串       &quot;,&quot; &quot; &quot;  //.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十-类和对象"><a href="#十-类和对象" class="headerlink" title="十.类和对象"></a>十.类和对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类</span></span><br><span class="line">	<span class="comment">/*封装性 继承性 多态性*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*1.所有成员变量都要用private</span></span><br><span class="line"><span class="comment">      2.成员变量的set和get函数</span></span><br><span class="line"><span class="comment">      3.无参构造函数            不写会赠送</span></span><br><span class="line"><span class="comment">      4.全参构造函数*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span>&#123;                        <span class="comment">//定义类 </span></span><br><span class="line">    String name;                             <span class="comment">//属性定义在方法外面</span></span><br><span class="line">    <span class="type">int</span> age=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rage;                        <span class="comment">// 类外无法直接访问 通过定义方法间接访问</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> classroom;                    <span class="comment">//静态类型</span></span><br><span class="line">    <span class="built_in">this</span>.name;                               <span class="comment">//指类内的属性值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;                      <span class="comment">//方法不加static</span></span><br><span class="line">        System.out.println(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">eat1</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;eat1&quot;</span>);         <span class="comment">//静态方法可以通过  student.eat1直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">student</span><span class="params">()</span>&#123;&#125;                      <span class="comment">//无参构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">student</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;    <span class="comment">//有参构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;System.out.println(<span class="string">&quot;第一次构造&quot;</span>);&#125; <span class="comment">//静态代码块在第一次构造时唯一使用一次</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。</span></span><br><span class="line"><span class="comment">例如：身体和心脏的关系。又如：汽车和发动机的关系。</span></span><br><span class="line"><span class="comment">分类：</span></span><br><span class="line"><span class="comment">1.成员内部类</span></span><br><span class="line"><span class="comment">2.局部内部类（包含匿名内部类）</span></span><br><span class="line"><span class="comment">成员内部类的定义格式：</span></span><br><span class="line"><span class="comment">修饰符class外部类名称f</span></span><br><span class="line"><span class="comment">修饰符class内部类名称f</span></span><br><span class="line"><span class="comment">注意：内用外，随意访问；外用内，需要内部类对象。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*继承特点: 单一继承性 多级继承性 多子类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">senerstudent</span> extend studend&#123;   <span class="comment">//定义子类继承父类</span></span><br><span class="line">    <span class="type">int</span> age=<span class="number">30</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> age=<span class="number">40</span>;</span><br><span class="line">    		System.out.println(age);       <span class="comment">//方法中的40</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.age);  <span class="comment">//类中的30</span></span><br><span class="line">            System.out.println(<span class="built_in">super</span>.age); <span class="comment">//父类的20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">senerstudent</span><span class="params">()</span>&#123;                 <span class="comment">//子类无参构造</span></span><br><span class="line">        <span class="built_in">super</span>();                           <span class="comment">//调用父类有参构造</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">senerstudent</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;    <span class="comment">//有参构造函数</span></span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">50</span>)                   <span class="comment">//调用父类有参构造函数</span></span><br><span class="line">    <span class="built_in">this</span>.name=name;</span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*方法覆盖重写的注意事项</span></span><br><span class="line"><span class="comment">		1.必须保证父子类之间方法的名称相同，参数列表也相同</span></span><br><span class="line"><span class="comment">		@override：写在方法前面，用来检测是不是有效的正确覆盖重写</span></span><br><span class="line"><span class="comment">		这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。</span></span><br><span class="line"><span class="comment">		2.子类方法的返回值必须【小于等于】父类方法的返回值范围。</span></span><br><span class="line"><span class="comment">		小扩展提示：java.lang.object类是所有类的公共最高父类（祖宗类），java.lang.string就是object的子类</span></span><br><span class="line"><span class="comment">		3.子类方法的权限必须【大于等于】类方法的权限修饰符。</span></span><br><span class="line"><span class="comment">		小扩展提示：public&gt;protected&gt;（default）&gt;private</span></span><br><span class="line"><span class="comment">		备注：（default）不是关键字default，而是什么都不写，留空。*/</span></span><br><span class="line">    <span class="comment">/*继承关系中，父子类构造方法的访问特点：</span></span><br><span class="line"><span class="comment">	1.子类构造方法当中有一个默认隐含的“super（）调用，所以一定是先调用的父类构造，后执行的子类构造。</span></span><br><span class="line"><span class="comment">	2.子类构造可以通过super关键字来调用父类重载构造。</span></span><br><span class="line"><span class="comment">	3.super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。</span></span><br><span class="line"><span class="comment">	总结：</span></span><br><span class="line"><span class="comment">	子类必须调用父类构造方法，不写则赠送super（）；写了则用写的指定的super调用，super只能有一个，还必须是第一个*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*多态性*/</span></span><br><span class="line"><span class="comment">/*代码当中体现多态性，其实就是一句话：父类引用指向子类对象。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">父类概称对象名=new子类名称（）；</span></span><br><span class="line"><span class="comment">或者：</span></span><br><span class="line"><span class="comment">接口名称</span></span><br><span class="line"><span class="comment">对象名=new实现类名称（）；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*在多态的代码当中，成员方法的访问规则是：</span></span><br><span class="line"><span class="comment">看new的是谁，就优先用谁，没有则向上找。</span></span><br><span class="line"><span class="comment">口诀：编译看左边，运行看右边。</span></span><br><span class="line"><span class="comment">对比一下：</span></span><br><span class="line"><span class="comment">成员变量：</span></span><br><span class="line"><span class="comment">编译看左边，运行还看左边。</span></span><br><span class="line"><span class="comment">成员方法：编译看左边，运行看右边。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String【】args)</span>&#123;</span><br><span class="line"><span class="comment">//使用多态的写法</span></span><br><span class="line"><span class="comment">//左侧父类的引用，指向了右侧子类的对象</span></span><br><span class="line">Fu obj= <span class="keyword">new</span> <span class="title class_">zi</span>（）;                     <span class="comment">//多态性</span></span><br><span class="line">obj.method（）;                         <span class="comment">//zi fu 都有 用子</span></span><br><span class="line">obj.methodFu（）;                       <span class="comment">//子无用父</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果不用多态，只用子类，那么写法是：</span></span><br><span class="line"><span class="comment">Teacher one new Teacher();</span></span><br><span class="line"><span class="comment">one.work():/∥讲课</span></span><br><span class="line"><span class="comment">Assistant two new Assistant();</span></span><br><span class="line"><span class="comment">two.work():/∥辅导</span></span><br><span class="line"><span class="comment">我现在唯一要做的事情，就是调用work方法，其他的功能不关心。</span></span><br><span class="line"><span class="comment">如果使用多态的写法，对比一下：</span></span><br><span class="line"><span class="comment">Employee one new TeacherO;</span></span><br><span class="line"><span class="comment">one,work():/∥讲课</span></span><br><span class="line"><span class="comment">Employee two new AssistantO;</span></span><br><span class="line"><span class="comment">two.work();/∥辅导</span></span><br><span class="line"><span class="comment">好处：无论右边new的时候换成哪个子类对象，等号左边调用方法都不会变化。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用类</span></span><br><span class="line"><span class="keyword">import</span> 路径.student                         <span class="comment">//导入包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">std</span>&#123;                           </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">student</span> <span class="variable">std</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>();       <span class="comment">//使用无参构造函数定义对象</span></span><br><span class="line">        std.name=<span class="string">&quot;阿凡达&quot;</span>;                  <span class="comment">//定义对象属性</span></span><br><span class="line">        std.age=<span class="number">100</span>;</span><br><span class="line">        std.eat();                         <span class="comment">//使用对象方法</span></span><br><span class="line">        student std1= <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;阿发说&quot;</span>,<span class="number">12</span>);<span class="comment">//使用全参构造函数定义对象</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十一-抽象类和抽象方法"><a href="#十一-抽象类和抽象方法" class="headerlink" title="十一.抽象类和抽象方法"></a>十一.抽象类和抽象方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。</span></span><br><span class="line"><span class="comment">抽象类：抽象方法所在的类，必须是抽象类才行。在class,之前写上abstract即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="comment">//这是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> eat（）;</span><br><span class="line"><span class="comment">//这是普通的成员方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> normalMethod（）&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如何使用抽象类和抽象方法：</span></span><br><span class="line"><span class="comment">1.不能直接创建new抽象类对象</span></span><br><span class="line"><span class="comment">2.必须用一个子类来继承抽象父类。</span></span><br><span class="line"><span class="comment">3.子类必须覆盖重写抽象父类当中所有的抽象方法。</span></span><br><span class="line"><span class="comment">覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。</span></span><br><span class="line"><span class="comment">4.创建子类对象进行使用。|*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> eat（）</span><br><span class="line">System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十二-转型"><a href="#十二-转型" class="headerlink" title="十二.转型"></a>十二.转型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>对象的向上转型，其实就是多态写法：</span><br><span class="line">格式：父类名称对象名=<span class="keyword">new</span>子类名称():</span><br><span class="line">Animal animal <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">含义：右侧创建一个子类对象，把它当做父类来看待使用。</span><br><span class="line">创建了一只猫，当做动物看待，没问题。</span><br><span class="line">注意事项：向上转型一定是安全的。从小范围转向了大范围，从小范围的猫，向上转换成为更大范围的动物。</span><br><span class="line">    </span><br><span class="line">向上转型一定是安全的，没有问题的，正确的。但是也有一个弊端：</span><br><span class="line">对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。</span><br><span class="line">解决方案：用对象的向下转型[还原]</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>对象的向下转型，其实是一个【还原】的动作。</span><br><span class="line">格式：子类名称对象名=（子类名称父类对象：</span><br><span class="line">含义：将父类对象，</span><br><span class="line">【还原】成为本来的子类对象。</span><br><span class="line">Animal animal=<span class="keyword">new</span> <span class="title class_">Cat</span>():/本来是猫，向上转型成为动物</span><br><span class="line">Catcat=(Cat)animal;;/∥本来是猫，已经被当做动物了，还原回来成为本来的猫</span><br><span class="line">注意事项：</span><br><span class="line">.必须保证对象本来创建的时候，就是猫，才能向下转型成为猫。</span><br><span class="line">b.如果对象创建的时候本来不是猫，现在非要向下转型成为猫，就会报错。ClassCastException</span><br><span class="line">    </span><br><span class="line">如何才能知道一个父类引用的对象，本来是什么子类？</span><br><span class="line">格式：</span><br><span class="line">对象<span class="keyword">instanceof</span>类名称</span><br><span class="line">这将会得到一个<span class="type">boolean</span>值结果，也就是判断前面的对象能不能当做后面类型的实例。</span><br></pre></td></tr></table></figure>



<h3 id="十三-接口"><a href="#十三-接口" class="headerlink" title="十三.接口"></a>十三.接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接口就是多个类的公共规范。</span></span><br><span class="line"><span class="comment">接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。</span></span><br><span class="line"><span class="comment">如何定义一个接口的格式：</span></span><br><span class="line"><span class="comment">public interface接口名称&#123;</span></span><br><span class="line"><span class="comment">//接口内容</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">备注：换成了关键字interface.之后，编译生成的字节码文件仍然是：。java--&gt;.class.</span></span><br><span class="line"><span class="comment">如果是Java7,那么接口中可以包含的内容有：</span></span><br><span class="line"><span class="comment">1.常量</span></span><br><span class="line"><span class="comment">2.抽象方法</span></span><br><span class="line"><span class="comment">如果是Java8,还可以额外包含有：</span></span><br><span class="line"><span class="comment">3.默认方法</span></span><br><span class="line"><span class="comment">4.静态方法</span></span><br><span class="line"><span class="comment">果是JavaT9,还可以额外包含有：</span></span><br><span class="line"><span class="comment">5.私有方法*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*接口使用步骤：</span></span><br><span class="line"><span class="comment">1.接口不能直接使用，必须有一个实现类来实现该接口。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public class 实现类名称 implements 接口名称()</span></span><br><span class="line"><span class="comment">2.</span></span><br><span class="line"><span class="comment">接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。</span></span><br><span class="line"><span class="comment">实现：去掉abstract关键字，加上方法体大括号。</span></span><br><span class="line"><span class="comment">3.</span></span><br><span class="line"><span class="comment">创建实现类的对象，进行使用。</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*1.接口的默认方法，可以通过接口实现类对象，直接调用</span></span><br><span class="line"><span class="comment">2.接口的默认方法，也可以被接口实现类进行覆盖重写。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*注意事项：不能通过接口实现类的对象来调用接口当中的静态方法。</span></span><br><span class="line"><span class="comment">正确用法：通过接口名称，直接调用其中的静态方法。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">接口名称。静态方法名（参数）；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用接口的时候，需要注意：</span></span><br><span class="line"><span class="comment">1.接口是没有静态代码块或者构造方法的。</span></span><br><span class="line"><span class="comment">2.</span></span><br><span class="line"><span class="comment">一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。</span></span><br><span class="line"><span class="comment">格式</span></span><br><span class="line"><span class="comment">public cLass MyInterfaceImpl implements MyInterfaceA,MyInterfaceB</span></span><br><span class="line"><span class="comment">//覆盖重写所有抽象方法</span></span><br><span class="line"><span class="comment">3.</span></span><br><span class="line"><span class="comment">如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。</span></span><br><span class="line"><span class="comment">5.</span></span><br><span class="line"><span class="comment">如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。</span></span><br><span class="line"><span class="comment">6.</span></span><br><span class="line"><span class="comment">一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*1.类与类之间是单继承的。直接父类只有一个。</span></span><br><span class="line"><span class="comment">2.类与接口之间是多实现的。一个类可以实现多个接口。</span></span><br><span class="line"><span class="comment">3.接口与接口之间是多继承的。</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">1.多个父接口当中的抽象方法如果重复，梁关系。</span></span><br><span class="line"><span class="comment">2.多个父接口当中的默认方法如果重复，邪么子接口必须进行默认方法的覆盖重写，[而且带着defaulti关键字]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">usb</span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在任何版本的Java中，接口都能定义抽象方法。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public abstract返回值类型方法名称（参数列表）；</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">1.接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract</span></span><br><span class="line"><span class="comment">2.这两个关键字修饰符，可以选择性地省略。(今天刚学，所以不推荐。)</span></span><br><span class="line"><span class="comment">3.</span></span><br><span class="line"><span class="comment">方法的三要素，可以随意定义。*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>;          <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>;                   <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>;                 <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span>;                          <span class="comment">//抽象方法</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment">/*从Java8开始，接口里允许定义默认方法。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public default返回值类型方法名称（参数列表）&#123;方法体&#125;</span></span><br><span class="line"><span class="comment">备注：接口当中的默认方法，可以解决接口升级的问题。*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">m5</span><span class="params">()</span>&#123;&#125;          <span class="comment">//默认方法        调用默认方法如果当前类中没有就会向上找</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*从]ava8开始，接口当中允许定义静态方法</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public static返回值类型方法名称（参数列表）&#123;&#125;</span></span><br><span class="line"><span class="comment">方法体</span></span><br><span class="line"><span class="comment">提示：就是将abstract或者default换成static即可，带上方法体。*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m6</span><span class="params">()</span>&#123;&#125;           <span class="comment">//静态方法         不能通过类的对象调用只能通过接口名称直接调用</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*问题描述：</span></span><br><span class="line"><span class="comment">我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题。</span></span><br><span class="line"><span class="comment">但是这个共有方法不应该让实现类使用，应该是私有化的。</span></span><br><span class="line"><span class="comment">解决方案：</span></span><br><span class="line"><span class="comment">从Java9开始，接口当中允许定义私有方法。</span></span><br><span class="line"><span class="comment">1.普通私有方法，解决多个默认方法之间重复代码问题</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">private返回值类型方法名称（参数列表）&#123;</span></span><br><span class="line"><span class="comment">方法体&#125;</span></span><br><span class="line"><span class="comment">2.</span></span><br><span class="line"><span class="comment">静态私有方法，解决多个静态方法之闸重复代码问题</span></span><br><span class="line"><span class="comment">棉式：</span></span><br><span class="line"><span class="comment">private static返回值类型方法名称（参数列表）&#123;</span></span><br><span class="line"><span class="comment">方法体&#125;*/</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/*接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。</span></span><br><span class="line"><span class="comment">从效果上看，这其实就是接口的【常量】。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public static final数据类型常量名称=数据值；</span></span><br><span class="line"><span class="comment">备注：</span></span><br><span class="line"><span class="comment">旦使用final关键字进行修饰，说明不可改变。</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">1.</span></span><br><span class="line"><span class="comment">接口当中的常量，可以省略public static final,注意：不写也照样是这样。</span></span><br><span class="line"><span class="comment">2.接口当中的常量，必须进行赋值；不能不赋值。</span></span><br><span class="line"><span class="comment">3.接口中常量的名称，使用完全大写的字母，用下划线进行分隔。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//这其实就是一个常量，一旦赋值，不可以修改</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> NUM_OF_MYCLASS <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十四-this和super专题"><a href="#十四-this和super专题" class="headerlink" title="十四.this和super专题"></a>十四.this和super专题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*super关键字的用法有三种：</span></span><br><span class="line"><span class="comment">1.在子类的成员方法中，访问父类的成员变量。</span></span><br><span class="line"><span class="comment">2. 在子类的成员方法中，访问父类的成员方法。</span></span><br><span class="line"><span class="comment">3.在子类的构造方法中，访问父类的构造方法。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*supe关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种：</span></span><br><span class="line"><span class="comment">1.在本类的成员方法中，访问本类的成员变量。</span></span><br><span class="line"><span class="comment">2.在本类的成员方法中，访问本类的另一个成员方法。</span></span><br><span class="line"><span class="comment">3.在本类的构造方法中，访问本类的另一个构造方法。</span></span><br><span class="line"><span class="comment">在第三种用法当中要注意：</span></span><br><span class="line"><span class="comment">4.this(..·)调用也必须是构造方法的第一个语句，唯一一个。</span></span><br><span class="line"><span class="comment">3.superi和this两种构造调用，不能同时使用。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="十五-final专题"><a href="#十五-final专题" class="headerlink" title="十五.final专题"></a>十五.final专题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*finali关键字代表最终、不可改变的。</span></span><br><span class="line"><span class="comment">常见四种用法：</span></span><br><span class="line"><span class="comment">1.</span></span><br><span class="line"><span class="comment">可以用来修饰一个类</span></span><br><span class="line"><span class="comment">2.可以用来修饰一个方法</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">还可以用来修饰一个局部变量</span></span><br><span class="line"><span class="comment">4.</span></span><br><span class="line"><span class="comment">还可以用来修饰一个成员变量*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*当final关键字用来修饰一个类的时候，格式：</span></span><br><span class="line"><span class="comment">public final class类名称f</span></span><br><span class="line"><span class="comment">.</span></span><br><span class="line"><span class="comment">含义：当前这个类不能有任何的子类。（太监类）</span></span><br><span class="line"><span class="comment">注意：一个类如果是fina(的，那么其中所有的成员方法都无法进行覆盖重写（因为没儿子。)*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当fial关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">修饰符final</span></span><br><span class="line"><span class="comment">返回值类型方法名称（参数列表）&#123;</span></span><br><span class="line"><span class="comment">/方法体</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">对于类、方法来说，abstracti关键字和final:关键字不能同时使用，因为矛盾。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对于局部变量来说</span></span><br><span class="line"><span class="comment">如果类型是基本类型那么不可变的是类型的值</span></span><br><span class="line"><span class="comment">如果类型是引用类型那么不可变的是类型的地址*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变。</span></span><br><span class="line"><span class="comment">1.由于成员变量具有默认值，所以用了final.之后必须手动赋值，不会再给默认值了。</span></span><br><span class="line"><span class="comment">2.对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。</span></span><br><span class="line"><span class="comment">3.</span></span><br><span class="line"><span class="comment">必须保证类当中所有重载的构造方法，都最终会对fna的成员变量进行赋值。*/</span></span><br></pre></td></tr></table></figure>

<h3 id="十六-public-protect-default-private-static-final-abstract"><a href="#十六-public-protect-default-private-static-final-abstract" class="headerlink" title="十六.public protect  default private static final abstract"></a>十六.public protect  default private static final abstract</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、修饰方法的修饰符</span><br><span class="line"><span class="keyword">public</span>:被该修饰符修饰的方法可以被任何类通过对象.方法使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:被该修饰符修饰的方法可以被该类自身、本包中的类、和子类（是子类而非父类）所使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:被该修饰符修饰的方法只能被该类使用</span><br><span class="line"></span><br><span class="line">缺省：被该修饰符修饰的方法只能被该类、本包中的类所使用（缺省的意思就是不用写）</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>：被<span class="keyword">static</span>修饰的方法是一个静态方法，可以被类直接使用，可以通过类名.方法名直接调用,<span class="keyword">static</span>可以和<span class="keyword">final</span>一起使用(在类中修饰的<span class="keyword">static</span>方法可以被对象和类名调用,但是在接口中定义的<span class="keyword">static</span>方法只能通过接口名调用)</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span>：被<span class="keyword">abstract</span>修饰的方法，不能写方法体，且该类必须是抽象类,抽象类中可以没有抽象方法，但是有抽象方法的类必须是一个抽象类</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span>：被该修饰符修饰的方法不能被重写</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、修饰类的修饰符</span><br><span class="line"><span class="keyword">public</span>：被<span class="keyword">public</span>修饰的类可以被任何类所使用（本包、其他包、自身）</span><br><span class="line"></span><br><span class="line">缺省：缺省的意思就是不写权限访问控制符，被此修饰符修饰的类只能被该类自身，本包中的类所使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span>：被此修饰符修饰的类是一个抽象类，抽象类是不能被实例化的，(抽象类主要是用来被继承的)，<span class="keyword">abstract</span>不能和<span class="keyword">final</span>同时修饰一个类</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span>：用<span class="keyword">final</span>修饰的类表示最终类，该类不能被继承，且该类也不能是一个抽象类</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、修饰成员变量的修饰符</span><br><span class="line"><span class="keyword">public</span>:被该修饰符修饰的成员变量可以被任何类使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:被该修饰符修饰的成员变量能被该类自身、本包中的类、和子类（是子类而非父类）所使用，即用<span class="keyword">protected</span>修饰的属性在其他包中的子类中可以通过子类对象进行访问，不能通过本类对象进行访问</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:被该修饰符修饰的成员变量只能被该类使用</span><br><span class="line"></span><br><span class="line">缺省：被该修饰符修饰的成员变量只能被该类、本包中的类所使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>：被<span class="keyword">static</span>修饰的成员变量可以被类直接使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span>:被该修饰符修饰的成员变量是常量</span><br></pre></td></tr></table></figure>

<h3 id="十七-常用api"><a href="#十七-常用api" class="headerlink" title="十七.常用api"></a>十七.常用api</h3><h4 id="object类"><a href="#object类" class="headerlink" title="object类"></a>object类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个类要么默认继承了Object类，要么间接继承了Object类，Object类是Java中的祖宗类。</span></span><br><span class="line"><span class="comment">Object作为所有类的父类，提供了很多常用的方法给每个子类对象拿来使用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">(object o)</span>      <span class="comment">// 默认是返回当前对象在堆内存中的地址信息：类的全限名@内存地址</span></span><br><span class="line">      <span class="comment">//父类toString()方法存在的意义就是为了被子类重写，以便返回对象的内容信息，而不是地址信息！！ </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equal</span><span class="params">(object o)</span>      <span class="comment">//默认是比较当前对象与另一个对象的地址是否相同，相同返回true,不同返回false</span></span><br><span class="line">      <span class="comment">//为了被子类重写，以便子类自己来定制比较规则（比如比较对象内容）。</span></span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<h4 id="objects类"><a href="#objects类" class="headerlink" title="objects类"></a>objects类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Objects是一个工具类，提供了一些方法去完成一些功能。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span>     <span class="comment">//比较两个对象的，底层会先进行非空判断，从而可以避免空指针异常。再进行equals比较</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNull</span><span class="params">(Object obj)</span>            <span class="comment">//判断变量是否为null ,为null返回true ,反之</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<h4 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*StringBuilder概述</span></span><br><span class="line"><span class="comment">StringBuilder是一个可变的字符串的操作类，我们可以把它看成是一个对象容器。</span></span><br><span class="line"><span class="comment">使用StringBuilder的核心作用：操作字符串的性能比String要更高（如拼接、修改等）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">()</span>                          <span class="comment">//创建一个空白的可变的字符串对象，不包含任何内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">(String str)</span>                <span class="comment">//创建一个指定字符串内容的可变字符串对象</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//常用方法</span></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(任意类型)</span>         <span class="comment">//添加数据并返回StringBuilder对象本身</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">reverse</span><span class="params">()</span>                     <span class="comment">//将对象的内容反转</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>                               <span class="comment">//返回对象内容长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>                       <span class="comment">//通过toString()就可以实现把StringBuilder转换为String</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Date-类概述"><a href="#Date-类概述" class="headerlink" title="Date 类概述"></a><strong>Date</strong> <strong>类概述</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Date类代表当前所在系统的日期时间信息。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Date</span><span class="params">()</span>          <span class="comment">//创建一个Date对象，代表的是系统当前此刻日期时间。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">(<span class="type">long</span> time)</span>    <span class="comment">//把时间毫秒值转换成Date日期对象。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTime</span><span class="params">()</span><span class="comment">//返回从1970年1月1日    00:00:00走到此刻的总的毫秒数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTime</span><span class="params">(<span class="type">long</span> time)</span>  <span class="comment">//设置日期对象的时间为当前时间毫秒值对应的时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a><strong>SimpleDateFormat</strong>类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*代表简单日期格式化，可以用来把日期时间格式化成为我们想要的形式。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> SimpleDateFormat​(String pattern) <span class="comment">//创建简单日期格式化对象，并封装格式化的形式信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">format</span><span class="params">(Date date)</span><span class="comment">//将日期格式化成日期/时间字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">format</span><span class="params">(Object time)</span><span class="comment">//将时间毫秒值式化成日期/时间字符串</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Date <span class="title function_">parse</span><span class="params">(String source)</span> <span class="comment">//  从给定字符串的开始解析文本以生成日期</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Calendar代表了系统此刻日期对应的日历对象。</span></span><br><span class="line"><span class="comment">Calendar是一个抽象类，不能直接创建对象。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title function_">getInstance</span><span class="params">()</span><span class="comment">//获取当前日历对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> field)</span>  <span class="comment">//取日期中的某个字段信息。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> field,<span class="type">int</span> value)</span><span class="comment">//修改日历的某个字段信息。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> field,<span class="type">int</span> amount)</span><span class="comment">//为某个字段增加/减少指定的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Date <span class="title function_">getTime</span><span class="params">()</span><span class="comment">//拿到此刻日期对象。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTimeInMillis</span><span class="params">()</span><span class="comment">//拿到此刻时间毫秒值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*注意：calendar是可变日期对象，一旦修改后其对象本身表示的时间将产生变化。*/</span></span><br></pre></td></tr></table></figure>

<h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">       <span class="comment">/* 基本类型      包装类</span></span><br><span class="line"><span class="comment">          byte     Byte</span></span><br><span class="line"><span class="comment">          short    Short</span></span><br><span class="line"><span class="comment">          int       Integer</span></span><br><span class="line"><span class="comment">          long      Long</span></span><br><span class="line"><span class="comment">          float     Float</span></span><br><span class="line"><span class="comment">          double    Double</span></span><br><span class="line"><span class="comment">          char       Character</span></span><br><span class="line"><span class="comment">          boolean    Boolean */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其实就是8种基本数据类型对应的引用类型。</span></span><br><span class="line"><span class="comment">Java为了实现一切皆对象，为8种基本类型提供了对应的引用类型。</span></span><br><span class="line"><span class="comment">后面的集合和泛型其实也只能支持包装类型，不支持基本数据类型。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">自动装箱：基本类型的数据和变量可以直接赋值给包装类型的变量。</span></span><br><span class="line"><span class="comment">自动拆箱：包装类型的变量可以直接赋值给基本数据类型的变量。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">包装类的特有功能</span></span><br><span class="line"><span class="comment">包装类的变量的默认值可以是null，容错率更高。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以把基本类型的数据转换成字符串类型(用处不大)</span></span><br><span class="line"><span class="comment">调用toString()方法得到字符串结果。</span></span><br><span class="line"><span class="comment">调用Integer.toString(基本类型的数据)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以把字符串类型的数值转换成真实的数据类型（真的很有用）</span></span><br><span class="line"><span class="comment">Integer.parseInt(“字符串类型的整数”)</span></span><br><span class="line"><span class="comment">Double.parseDouble(“字符串类型的小数”)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串对象提供了匹配正则表达式的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> matches​(String regex)        <span class="comment">//判断是否匹配正则表达式，匹配返回true，不匹配返回false。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    字符类(默认匹配一个字符)</span></span><br><span class="line"><span class="comment">[abc]	       只能是a, b, 或c</span></span><br><span class="line"><span class="comment">[^abc]	       除了a, b, c之外的任何字符</span></span><br><span class="line"><span class="comment">[a-zA-Z]               a到z A到Z，包括（范围）</span></span><br><span class="line"><span class="comment">[a-d[m-p]]	       a到d，或m通过p：（[a-dm-p]联合）</span></span><br><span class="line"><span class="comment">[a-z&amp;&amp;[def]]	       d, e, 或f(交集)</span></span><br><span class="line"><span class="comment">[a-z&amp;&amp;[^bc]]	       a到z，除了b和c：（[ad-z]减法）</span></span><br><span class="line"><span class="comment">[a-z&amp;&amp;[^m-p]]     a到z，除了m到p：（[a-lq-z]减法）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">预定义的字符类(默认匹配一个字符)</span></span><br><span class="line"><span class="comment">.	任何字符</span></span><br><span class="line"><span class="comment">\d	一个数字： [0-9]</span></span><br><span class="line"><span class="comment">\D	非数字： [^0-9]</span></span><br><span class="line"><span class="comment">\s	一个空白字符： [ \t\n\x0B\f\r]</span></span><br><span class="line"><span class="comment">\S	非空白字符： [^\s]</span></span><br><span class="line"><span class="comment">\w	[a-zA-Z_0-9] 英文、数字、下划线</span></span><br><span class="line"><span class="comment">\W	 [^\w] 一个非单词字符</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">贪婪的量词（配合匹配多个字符）</span></span><br><span class="line"><span class="comment">X?	X , 一次或根本不</span></span><br><span class="line"><span class="comment">X*	X，零次或多次</span></span><br><span class="line"><span class="comment">X+	X , 一次或多次</span></span><br><span class="line"><span class="comment">X &#123;n&#125;	X，正好n次</span></span><br><span class="line"><span class="comment">X &#123;n, &#125;	X，至少n次</span></span><br><span class="line"><span class="comment">X &#123;n,m&#125;	X，至少n但不超过m次</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">&quot;z&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="string">&quot;ab&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="string">&quot;ab&quot;</span>.matches(<span class="string">&quot;[abc]+&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组操作工具类，专门用于操作数组元素的。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(类型[] a)</span>             <span class="comment">//返回数组的内容（字符串形式）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(类型[] a)</span>                   <span class="comment">//对数组进行默认升序排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(类型[] a, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span>    <span class="comment">//使用比较器对象自定义排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> key)</span>            <span class="comment">//二分搜索数组中的数据，存在返回索引，不存在返回-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="十八-集合"><a href="#十八-集合" class="headerlink" title="十八.集合"></a>十八.集合</h3><p>集合分为Collection单列和Map双列集合</p>
<p>Collection接口有两个继承接口,List和Set</p>
<p>List接口有两个实现类,**ArrayList、LinekdList **</p>
<p>Set接口有两个实现类,<strong>HashSet.TreeSet</strong>,HashSet有个继承类为LinkedHashSet</p>
<p>Collection集合特点:</p>
<p><strong>List系列集合</strong>：添加的元素是有序、可重复、有索引。</p>
<p>ArrayList、LinekdList ：有序、可重复、有索引。</p>
<p><strong>Set系列集合</strong>：添加的元素是无序、不重复、无索引。</p>
<p>HashSet: 无序、不重复、无索引；LinkedHashSet: <strong>有序</strong>、不重复、无索引。</p>
<p>TreeSet：<strong>按照大小默认升序排序、</strong>不重复、无索引。</p>
<p><strong>注意：集合和泛型都只能支持引用数据类型，不支持基本数据类型，所以集合中存储的元素都认为是对象。</strong></p>
<h4 id="Collection-API"><a href="#Collection-API" class="headerlink" title="Collection API"></a>Collection API</h4><p>Collection是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的。</p>
<p><strong>Collection API如下:</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  boolean add(E e)</td>
<td>把给定的对象添加到当前集合中</td>
</tr>
<tr>
<td>public  void clear()</td>
<td>清空集合中所有的元素</td>
</tr>
<tr>
<td>public  boolean remove(E e)</td>
<td>把给定的对象在当前集合中删除</td>
</tr>
<tr>
<td>public  boolean contains(Object obj)</td>
<td>判断当前集合中是否包含给定的对象</td>
</tr>
<tr>
<td>public  boolean isEmpty()</td>
<td>判断当前集合是否为空</td>
</tr>
<tr>
<td>public  int size()</td>
<td>返回集合中元素的个数。</td>
</tr>
<tr>
<td>public  Object[] toArray()</td>
<td>把集合中的元素，存储到数组中</td>
</tr>
</tbody></table>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><h5 id="方式一：迭代器"><a href="#方式一：迭代器" class="headerlink" title="方式一：迭代器"></a>方式一：迭代器</h5><p>迭代器在Java中的代表是<strong>Iterator</strong>，迭代器是集合的专用的遍历方式。</p>
<p><strong>Collection****集合获取迭代器</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Iterator<E></strong>  <strong>iterator()</strong></td>
<td>返回集合中的迭代器对象，该迭代器对象默认指向当前集合的0索引</td>
</tr>
</tbody></table>
<p><strong>Iterator****中的常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean hasNext()</td>
<td>询问当前位置是否有元素存在，存在返回true ,不存在返回false</td>
</tr>
<tr>
<td>E  next()</td>
<td>获取当前位置的元素，并同时将迭代器对象移向下一个位置，注意防止取出越界。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = lists.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="方式二：foreach-增强for循环"><a href="#方式二：foreach-增强for循环" class="headerlink" title="方式二：foreach/增强for循环"></a>方式二：foreach/增强for循环</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for(元素数据类型 变量名 : 数组或者Collection集合) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //在此处使用变量即可，该变量就是元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">既可以遍历集合也可以遍历数组。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Collection&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String ele : list) &#123;</span><br><span class="line">        System.out.println(ele);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="方式三：lambda表达式"><a href="#方式三：lambda表达式" class="headerlink" title="方式三：lambda表达式"></a>方式三：lambda表达式</h5><h4 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h4><p><strong>List系列集合特点</strong></p>
<p> ArrayList、LinekdList ：有序，可重复，有索引。</p>
<p>有序：存储和取出的元素顺序一致</p>
<p>有索引：可以通过索引操作元素</p>
<p>可重复：存储的元素可以重复</p>
<p><strong>List</strong> <strong>集合特有方法</strong></p>
<p>List集合因为支持索引，所以多了很多索引操作的独特api，其他Collection的功能List也都继承了。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void add(int  index,E element)</td>
<td>在此集合中的指定位置插入指定的元素</td>
</tr>
<tr>
<td>E remove(int  index)</td>
<td>删除指定索引处的元素，返回被删除的元素</td>
</tr>
<tr>
<td>E set(int index,E  element)</td>
<td>修改指定索引处的元素，返回被修改的元素</td>
</tr>
<tr>
<td>E get(int  index)</td>
<td>返回指定索引处的元素</td>
</tr>
</tbody></table>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p><strong>ArrayList</strong> <strong>集合底层原理</strong></p>
<p>ArrayList底层是基于数组实现的：根据索引定位元素快，增删需要做元素的移位操作。</p>
<p>第一次创建集合并添加第一个元素的时候，在底层创建一个默认长度为10的数组。</p>
<p>当长度超过当前数组长时,创建一个更大的数组,并对老数组进行迁移</p>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p><strong>LinkedList</strong> <strong>的特点</strong></p>
<p>l底层数据结构是双链表，查询慢，首尾操作的速度是极快的，所以多了很多首尾操作的特有API。</p>
<p><strong>LinkedList</strong> <strong>集合的特有功能</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  void addFirst(E e)</td>
<td>在该列表开头插入指定的元素</td>
</tr>
<tr>
<td>public  void addLast(E e)</td>
<td>将指定的元素追加到此列表的末尾</td>
</tr>
<tr>
<td>public  E getFirst()</td>
<td>返回此列表中的第一个元素</td>
</tr>
<tr>
<td>public  E getLast()</td>
<td>返回此列表中的最后一个元素</td>
</tr>
<tr>
<td>public  E removeFirst()</td>
<td>从此列表中删除并返回第一个元素</td>
</tr>
<tr>
<td>public  E removeLast()</td>
<td>从此列表中删除并返回最后一个元素</td>
</tr>
</tbody></table>
<p>当我们从集合中找出某个元素并删除的时候可能出现一种并发修改异常问题。</p>
<p>删除当前元素,指针后移会导致跳过删除元素后一个元素.</p>
<p>迭代器遍历集合且直接用集合删除元素的时候可能出现。</p>
<p>迭代器遍历集合但是用迭代器自己的删除方法操作可以解决。</p>
<p>增强for循环遍历集合且直接用集合删除元素的时候可能出现。</p>
<p>使用for循环遍历并删除元素不会存在这个问题。</p>
<h5 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h5><p>泛型：是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查。</p>
<p>泛型的格式：&lt;数据类型&gt;; 注意：泛型只能支持引用数据类型。</p>
<p>集合体系的全部接口和实现类都是支持泛型的使用的。</p>
<p><strong>泛型的好处：</strong></p>
<p>统一数据类型。</p>
<p>把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为编译阶段类型就能确定下来。</p>
<p>泛型有:泛型类,泛型方法,泛型接口</p>
<p>泛型类</p>
<p>定义类时同时定义了泛型的类就是泛型类。</p>
<p>泛型类的格式：修饰符 class 类名&lt;泛型变量&gt;{ }</p>
<p>泛型方法</p>
<p>定义方法时同时定义了泛型的方法就是泛型方法。</p>
<p>泛型方法的格式：修饰符 &lt;泛型变量&gt; 方法返回值 方法名称(形参列表){}</p>
<p>泛型接口</p>
<p>使用了泛型定义的接口就是泛型接口。</p>
<p>泛型接口的格式：修饰符 interface 接口名称&lt;泛型变量&gt;{}</p>
<p>? 可以在“使用泛型”的时候代表一切类型。</p>
<p> E T K V 是在定义泛型的时候使用的。</p>
<p>通配符上下限:</p>
<p>? <strong>extends</strong> <strong>Car</strong>: ?必须是Car或者其子类  泛型上限</p>
<p> ? <strong>super</strong> <strong>Car</strong> ： ?必须是Car或者其父类  泛型下限</p>
<h4 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h4><p><strong>Set</strong> <strong>系列集合特点</strong></p>
<p>无序：存取顺序不一致</p>
<p>不重复：可以去除重复</p>
<p>无索引：没有带索引的方法，所以不能使用普通for循环遍历，也不能通过索引来获取元素。</p>
<p><strong>Set</strong> <strong>集合</strong> <strong>实现类特点</strong></p>
<p> HashSet : 无序、不重复、无索引。</p>
<p>LinkedHashSet：<strong>有序</strong>、不重复、无索引。</p>
<p>TreeSet：<strong>排序</strong>、不重复、无索引。</p>
<p><strong>Set</strong> <strong>集合的功能上基本上与</strong> <strong>Collection</strong> <strong>的</strong> <strong>API</strong> <strong>一致。</strong></p>
<h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a><strong>HashSet</strong></h5><p><strong>HashSet</strong> <strong>底层原理</strong></p>
<p>HashSet集合底层采取<strong>哈希表</strong>存储的数据。</p>
<p>哈希表是一种对于增删改查数据性能都较好的结构。</p>
<p><strong>哈希表的组成</strong></p>
<p>JDK8之前的，底层使用<strong>数组</strong> <strong>+</strong> <strong>链表</strong>组成</p>
<p>JDK8开始后，底层采用<strong>数组</strong> <strong>+</strong> <strong>链表</strong> <strong>+</strong> <strong>红黑树</strong>组成。</p>
<p>在了解哈希表之前需要先理解哈希值的概念:是JDK根据对象的<strong>地址</strong> <strong>，</strong>按照某种规则算出来的int类型的<strong>数值。</strong></p>
<p><strong>Object</strong> <strong>类的</strong> <strong>API</strong></p>
<p>public int hashCode()：返回对象的哈希值</p>
<p>同一个对象多次调用hashCode()方法返回的哈希值是相同的</p>
<p>默认情况下，不同对象的哈希值是不同的。</p>
<p><strong>HashSet1.7</strong> <strong>版本原理解析：数组</strong> <strong>+</strong> <strong>链表</strong> <strong>+</strong> <strong>（结合哈希算法）</strong></p>
<p>①创建一个默认长度16的数组，数组名table</p>
<p>②根据元素的哈希值跟数组的长度求余计算出应存入的位置（哈希算法）</p>
<p>③判断当前位置是否为null，如果是null直接存入</p>
<p>④如果位置不为null，表示有元素，则调用equals方法比较</p>
<p>⑤如果一样，则不存，如果不一样，则存入数组，</p>
<p>JDK 7新元素占老元素位置，指向老元素</p>
<p>JDK 8中新元素挂在老元素下面</p>
<p><strong>JDK1.8</strong> <strong>版本开始</strong> <strong>HashSet</strong> <strong>原理解析</strong></p>
<p>底层结构：哈希表（数组、链表、红黑树的结合体）</p>
<p>当挂在元素下面的数据过多时，查询性能降低，从JDK8开始后，当链表长度超过<strong>8</strong>的时候，自动转换为红黑树。</p>
<p><strong>HashSet</strong> <strong>去重复原理解析</strong></p>
<p> ①创建一个默认长度16的数组，数组名table</p>
<p>②根据元素的<strong>哈希值</strong>跟<strong>数组的长度求余</strong>计算出应存入的位置<strong>（哈希算法）</strong></p>
<p>③判断当前位置是否为null，如果是null直接存入</p>
<p>④<strong>如果位置不为</strong> <strong>null</strong> <strong>，表示有元素，则调用</strong> <strong>equals</strong> <strong>方法比较</strong></p>
<p>⑤<strong>如果一样，则不存，如果不一样，则存入数组，</strong></p>
<p><strong>结论：如果希望</strong> <strong>Set</strong> <strong>集合认为</strong> <strong>2</strong> <strong>个内容一样的对象是重复的，</strong></p>
<p><strong>必须重写对象的</strong> <strong>hashCode</strong> <strong>()</strong> <strong>和</strong> <strong>equals()</strong> <strong>方法</strong></p>
<h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><p><strong>LinkedHashSet</strong> <strong>集合概述和特点</strong></p>
<p><strong>有序</strong>、不重复、无索引。</p>
<p>这里的有序指的是保证存储和取出的元素顺序一致</p>
<p><strong>原理</strong>：底层数据结构是依然哈希表，只是每个元素又额外的多了一个双链表的机制记录存储的顺序。</p>
<h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p><strong>TreeSet</strong> <strong>集合概述和特点</strong></p>
<p>不重复、无索引、可排序</p>
<p>可排序：按照元素的大小默认升序（有小到大）排序。</p>
<p>TreeSet集合底层是基于红黑树的数据结构实现排序的，增删改查性能都较好。</p>
<p><strong>注意：</strong> <strong>TreeSet</strong> <strong>集合是一定要排序的，可以将元素按照指定的规则进行排序。</strong></p>
<p>对于数值类型：Integer , Double，官方默认按照大小进行升序排序。</p>
<p>对于字符串类型：默认按照首字符的编号升序排序。</p>
<p>对于自定义类型如Student对象，TreeSet无法直接排序。</p>
<p><strong>结论：想要使用</strong> <strong>TreeSet</strong> <strong>存储自定义类型，需要制定排序规则</strong></p>
<p><strong>自定义排序规则</strong></p>
<p>lTreeSet集合存储对象的的时候有2种方式可以设计自定义比较规则</p>
<p><strong>方式一</strong></p>
<p>让自定义的类（如学生类）<strong>实现</strong> <strong>Comparable</strong> <strong>接口</strong>重写里面的<strong>compareTo</strong>方法<strong>来定制比较规则。</strong></p>
<p><strong>方式二</strong>(优先级高)</p>
<p><strong>TreeSet</strong> <strong>集合有参数构造器，可以设置</strong> <strong>Comparator</strong> <strong>接口对应的比较器对象，来定制比较规则。</strong></p>
<p><strong>两种方式中，关于返回值的规则：</strong></p>
<p>l如果认为第一个元素大于第二个元素返回正整数即可。</p>
<p>l如果认为第一个元素小于第二个元素返回负整数即可。</p>
<p>l如果认为第一个元素等于第二个元素返回0即可，此时Treeset集合只会保留一个元素，认为两者重复。</p>
<p><strong>注意：如果</strong> <strong>TreeSet</strong> <strong>集合存储的对象有实现比较规则，集合也自带比较器，默认使用集合自带的比较器排序。</strong></p>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>可变参数用在形参中可以接收多个数据。</p>
<p>可变参数的格式：数据类型…参数名称</p>
<p>接收参数非常灵活，方便。可以不接收参数，可以接收1个或者多个参数，也可以接收一个数组</p>
<p><strong>可变参数在方法内部本质上就是一个数组。</strong></p>
<p>1.一个形参列表中可变参数只能有一个</p>
<p>2.可变参数必须放在形参列表的最后面</p>
<h4 id="Collections-集合工具类"><a href="#Collections-集合工具类" class="headerlink" title="Collections 集合工具类"></a><strong>Collections</strong> <strong>集合工具类</strong></h4><p>java.utils.Collections:是集合工具类</p>
<p>作用：Collections并不属于集合，是用来操作集合的工具类。</p>
<p><strong>Collections常用的API</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static <T> boolean  addAll(Collection&lt;? super T&gt; c, T… elements)</td>
<td>给集合对象批量添加元素</td>
</tr>
<tr>
<td>public static void shuffle(List&lt;?&gt; list)</td>
<td>打乱List集合元素的顺序</td>
</tr>
</tbody></table>
<p><strong>Collections</strong> <strong>排序相关</strong> <strong>API</strong></p>
<p>使用范围：只能对于List集合的排序。</p>
<p><strong>排序方式</strong> <strong>1</strong> <strong>：</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static <T> void sort(List<T> list)</td>
<td>将集合中元素按照默认规则排序</td>
</tr>
</tbody></table>
<p>注意：本方式不可以直接对自定义类型的List集合排序，除非自定义类型实现了比较规则Comparable接口。</p>
<p><strong>排序方式</strong> <strong>2</strong> <strong>：</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static <T> void sort(List<T> list，Comparator&lt;? super T&gt; c)</td>
<td>将集合中元素按照指定规则排序</td>
</tr>
</tbody></table>
<h4 id="MAP集合"><a href="#MAP集合" class="headerlink" title="MAP集合"></a>MAP集合</h4><p><strong>Map</strong> <strong>集合概述和使用</strong></p>
<p>Map集合是一种双列集合，每个元素包含两个数据。</p>
<p>Map集合的每个元素的格式：key=value(键值对元素)。</p>
<p>Map集合也被称为“<strong>键值对集合</strong>”。</p>
<p><strong>Map</strong> <strong>集合整体格式：</strong></p>
<p>Collection集合的格式: [元素1,元素2,元素3..]</p>
<p>Map集合的完整格式：{key1=value1 , key2=value2 , key3=value3 , …}</p>
<p><img src="/2022/11/22/JAVA/Snipaste_2022-11-04_18-56-31.png"></p>
<p><strong>使用最多的</strong> <strong>Map</strong> <strong>集合是</strong> <strong>HashMap</strong> <strong>。</strong></p>
<p>重点掌握HashMap , LinkedHashMap , TreeMap。其他的后续理解。</p>
<p><strong>Map</strong> <strong>集合的键</strong> <strong>无序、不重复的</strong></p>
<p><strong>Map</strong> <strong>集合的值</strong> <strong>值不做要求</strong> <strong>可以重复</strong></p>
<p><strong>Map集合体系特点</strong></p>
<p>Map集合的特点都是由键决定的。</p>
<p>Map集合的键是无序,不重复的，无索引的，值不做要求（可以重复）。</p>
<p>Map集合后面重复的键对应的值会覆盖前面重复键的值。</p>
<p>Map集合的键值对都可以为null。</p>
<p><strong>Map集合实现类特点</strong></p>
<p>HashMap:元素按照键是无序，不重复，无索引，值不做要求。（与Map体系一致）</p>
<p>LinkedHashMap:元素按照键是<strong>有序</strong>，不重复，无索引，值不做要求。</p>
<p>TreeMap：元素按照建是<strong>排序</strong>，不重复，无索引的，值不做要求。</p>
<p><strong>Map集合</strong> </p>
<p>Map是双列集合的祖宗接口，它的功能是全部双列集合都可以继承使用的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map &lt;String,Integer&gt; maps =new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>V  put(K key,V value)</td>
<td>添加元素</td>
</tr>
<tr>
<td>V  remove(Object key)</td>
<td>根据键删除键值对元素</td>
</tr>
<tr>
<td>void  clear()</td>
<td>移除所有的键值对元素</td>
</tr>
<tr>
<td>boolean containsKey(Object key)</td>
<td>判断集合是否包含指定的键</td>
</tr>
<tr>
<td>boolean containsValue(Object value)</td>
<td>判断集合是否包含指定的值</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断集合是否为空</td>
</tr>
<tr>
<td>int  size()</td>
<td>集合的长度，也就是集合中键值对的个数</td>
</tr>
</tbody></table>
<p><strong>Map集合的遍历方式有：3种。</strong></p>
<p>方式一：键找值的方式遍历：先获取Map集合全部的键，再根据遍历键找值。</p>
<p>方式二：键值对的方式遍历，把“键值对“看成一个整体，难度较大。</p>
<p>方式三：JDK 1.8开始之后的新技术：Lambda表达式。</p>
<p><strong>Map集合的遍历方式一：键找值</strong></p>
<p>先获取Map集合的全部键的Set集合。</p>
<p>遍历键的Set集合，然后通过键提取对应值。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Set<K>  keySet()</td>
<td>获取所有键的集合</td>
</tr>
<tr>
<td>V  get(Object key)</td>
<td>根据键获取值</td>
</tr>
</tbody></table>
<p><strong>Map集合的遍历方式二：键值对</strong></p>
<p>先把Map集合转换成Set集合，Set集合中每个元素都是键值对实体类型了。</p>
<p>遍历Set集合，然后提取键以及提取值。</p>
<p><strong>键值对涉及到的API:</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td>
<td>获取所有键值对对象的集合</td>
</tr>
<tr>
<td>K getKey()</td>
<td>获得键</td>
</tr>
<tr>
<td>V getValue()</td>
<td>获取值</td>
</tr>
</tbody></table>
<p><strong>Map集合的遍历方式三Lambda</strong></p>
<p>得益于JDK 8开始的新技术Lambda表达式，提供了一种更简单、更直接的遍历集合的方式。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>default void forEach(BiConsumer&lt;?  super  K,  ? super  V&gt;  action)</td>
<td>结合lambda遍历Map集合</td>
</tr>
</tbody></table>
<p><img src="/2022/11/22/JAVA/Snipaste_2022-11-04_19-17-39.png"></p>
<h5 id="HashMap的特点"><a href="#HashMap的特点" class="headerlink" title="HashMap的特点"></a><strong>HashMap的特点</strong></h5><p>HashMap是Map里面的一个实现类。特点都是由键决定的：无序、不重复、无索引</p>
<p>没有额外需要学习的特有方法，直接使用Map里面的方法就可以了。</p>
<p>HashMap跟HashSet底层原理是一模一样的，都是哈希表结构，只是HashMap的每个元素包含两个值而已。</p>
<p><strong>实际上：Set系列集合的底层就是Map实现的，只是Set集合中的元素只要键数据，不要值数据而已。</strong></p>
<p><strong>1.HashMap的特点和底层原理</strong></p>
<p>由键决定：无序、不重复、无索引。HashMap底层是哈希表结构的。</p>
<p>依赖hashCode方法和equals方法保证<strong>键</strong>的唯一。</p>
<p>如果<strong>键</strong>要存储的是自定义对象，需要重写hashCode和equals方法。</p>
<p>基于哈希表。增删改查的性能都较好。</p>
<h5 id="LinkedHashMap集合概述和特点"><a href="#LinkedHashMap集合概述和特点" class="headerlink" title="LinkedHashMap集合概述和特点"></a><strong>LinkedHashMap集合概述和特点</strong></h5><p><strong>由键决定：有序</strong>、不重复、无索引。</p>
<p>这里的有序指的是保证存储和取出的元素顺序一致</p>
<p><strong>原理</strong>：底层数据结构是依然哈希表，只是每个键值对元素又额外的多了一个双链表的机制记录存储的顺序。</p>
<h5 id="TreeMap集合概述和特点"><a href="#TreeMap集合概述和特点" class="headerlink" title="TreeMap集合概述和特点"></a><strong>TreeMap集合概述和特点</strong></h5><p>由键决定特性：不重复、无索引、可排序</p>
<p>可排序：按照键数据的大小默认升序（有小到大）排序。<strong>只能对键排序。</strong></p>
<p><strong>注意：TreeMap集合是一定要排序的，可以默认排序，也可以将键按照指定的规则进行排序</strong></p>
<p>TreeMap跟TreeSet一样底层原理是一样的。</p>
<p><strong>TreeMap集合自定义排序规则有2种</strong></p>
<p>类实现Comparable接口，重写比较规则。</p>
<p>集合自定义Comparator比较器对象，重写比较规则。</p>
<h5 id="Map集合实现类特点"><a href="#Map集合实现类特点" class="headerlink" title="Map集合实现类特点"></a><strong>Map集合实现类特点</strong></h5><p>HashMap:元素按照键是无序，不重复，无索引，值不做要求，基于哈希表（与Map体系一致）</p>
<p>LinkedHashMap:元素按照键是<strong>有序</strong>，不重复，无索引，值不做要求，基于哈希表</p>
<p>TreeMap：元素只能按照键<strong>排序</strong>，不重复，无索引的，值不做要求，可以做排序</p>
<h4 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h4><p>不可变集合，就是不可被修改的集合。集合的数据项在创建的时候提供，并且在整个生命周期中都不可改变。否则报错。</p>
<p>在List、Set、Map接口中，都存在of方法，可以创建一个不可变的集合。</p>
<p><code>static &lt;E&gt;List&lt;E&gt;of(E…elements)</code></p>
<p><code>static &lt;E&gt;Set&lt;E&gt; of(E…elements)</code></p>
<p><code>static &lt;K , V&gt;Map&lt;K，V&gt; of(E…elements)</code></p>
<h4 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h4><h5 id="Stream流的概述"><a href="#Stream流的概述" class="headerlink" title="Stream流的概述"></a>Stream流的概述</h5><p>什么是Stream流</p>
<p>在Java 8中，得益于Lambda所带来的函数式编程，引入了一个全新的Stream流概念。目的：用于简化集合和数组操作的API。</p>
<p>Stream流式思想的核心：</p>
<p>1.先得到集合或者数组的Stream流（就是一根传送带）</p>
<p>2.把元素放上去</p>
<p>3.然后就用这个Stream流简化的API来方便的操作元素。</p>
<p>Stream流的三类方法</p>
<p>获取Stream流:创建一条流水线，并把数据放到流水线上准备进行操作</p>
<p>中间方发:流水线上的操作。一次操作完毕之后，还可以继续进行其他操作。</p>
<p>终结方法:一个Stream流只能有一个终结方法，是流水线上的最后一个操作</p>
<h5 id="Stream流的获取"><a href="#Stream流的获取" class="headerlink" title="Stream流的获取"></a>Stream流的获取</h5><p>Stream操作集合或者数组的第一步是先得到Stream流，然后才能使用流的功能。</p>
<p>集合可以使用Collection接口中的默认方法stream()生成流</p>
<p><code>default Stream&lt;E&gt; stream()</code></p>
<p>数组获取Stream流的方式</p>
<p><code>public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array)</code>  获取当前数组的Stream流</p>
<p><code>public static&lt;T&gt; Stream&lt;T&gt; of(T...values)</code>获取当前数组/可变数据的Stream流</p>
<h5 id="Stream流的常用API-中间操作方法"><a href="#Stream流的常用API-中间操作方法" class="headerlink" title="Stream流的常用API(中间操作方法)"></a>Stream流的常用API(中间操作方法)</h5><p>名称                                                                                        说明</p>
<p><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code>            用于对流中的数据进行过滤。</p>
<p><code>Stream&lt;T&gt; limit(long maxSize)        </code>                    获取前几个元素</p>
<p><code>Stream&lt;T&gt; skip(long n)    </code>                        跳过前几个元素</p>
<p><code>Stream&lt;T&gt; distinct()</code>                            去除流中重复的元素。依赖(hashCode和equals方法)</p>
<p>static <T> Stream<T> concat(Stream a, Stream b)            合并a和b两个流为一个流</p>
<p>注意：</p>
<p>中间方法也称为非终结方法，调用完成后返回新的Stream流可以继续使用，支持链式编程。</p>
<p>在Stream流中无法直接修改集合、数组中的数据。</p>
<h5 id="Stream流的常见终结操作方法"><a href="#Stream流的常见终结操作方法" class="headerlink" title="Stream流的常见终结操作方法"></a>Stream流的常见终结操作方法</h5><p>名称                                                                说明</p>
<p><code>void forEach(Consumer action)        </code>对此流的每个元素执行遍历操作</p>
<p><code>long count()    </code>                    返回此流中的元素数注意：终结操作方法，调用完成后流就无法继续使用了，原因是不会返回Stream了。</p>
<h5 id="Stream流的收集操作"><a href="#Stream流的收集操作" class="headerlink" title="Stream流的收集操作"></a>Stream流的收集操作</h5><p>收集Stream流的含义：就是把Stream流操作后的结果数据转回到集合或者数组中去。</p>
<p>Stream流：方便操作集合/数组的手段。集合/数组：才是开发中的目的。</p>
<p>Stream流的收集方法</p>
<p>名称                                                            说明</p>
<p><code>R collect(Collector collector)    </code>    开始收集Stream流，指定收集器</p>
<p>Collectors工具类提供了具体的收集方式</p>
<p>名称                                                                                说明</p>
<p><code>public static &lt;T&gt; Collector toList()        </code>    把元素收集到List集合中</p>
<p><code>public static &lt;T&gt; Collector toSet()    </code>        把元素收集到Set集合中</p>
<p><code>public staticCollector toMap(Function keyMapper , Function valueMapper)    </code>    把元素收集到Map集合中</p>
<h3 id="十九-异常"><a href="#十九-异常" class="headerlink" title="十九.异常"></a>十九.异常</h3><h4 id="异常概述、体系"><a href="#异常概述、体系" class="headerlink" title="异常概述、体系"></a>异常概述、体系</h4><p>异常是程序在“编译”或者“执行”的过程中可能出现的问题，注意：语法错误不算在异常体系中。比如:数组索引越界、空指针异常、日期格式化异常，等…</p>
<p><img src="/2022/11/22/JAVA/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.PNG"></p>
<p>Error：系统级别问题、JVM退出等，代码无法控制。</p>
<p>Exception：java.lang包下，称为异常类，它表示程序本身可以处理的问题</p>
<p>RuntimeException及其子类：运行时异常，编译阶段不会报错。(空指针异常，数组索引越界异常)</p>
<p>除RuntimeException之外所有的异常：编译时异常，编译期必须处理的，否则程序不能通过编译。(日期格式化异常)。</p>
<h4 id="常见运行时异常"><a href="#常见运行时异常" class="headerlink" title="常见运行时异常"></a>常见运行时异常</h4><p>直接继承自RuntimeException或者其子类，编译阶段不会报错，运行时可能出现的错误。</p>
<p>数组索引越界异常:ArrayIndexOutOfBoundsException</p>
<p>空指针异常:NullPointerException，直接输出没有问题，但是调用空指针的变量的功能就会报错。</p>
<p>类型转换异常：ClassCastException</p>
<p>数学操作异常：ArithmeticException</p>
<p>数字转换异常：NumberFormatException</p>
<h4 id="常见编译时异常"><a href="#常见编译时异常" class="headerlink" title="常见编译时异常"></a>常见编译时异常</h4><p>不是RuntimeException或者其子类的异常，编译阶就报错，必须处理，否则代码不通过。</p>
<h4 id="异常的默认处理流程"><a href="#异常的默认处理流程" class="headerlink" title="异常的默认处理流程"></a>异常的默认处理流程</h4><p>①默认会在出现异常的代码那里自动的创建一个异常对象：ArithmeticException。</p>
<p>②异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给JVM虚拟机。</p>
<p>③虚拟机接收到异常对象后，先在控制台直接输出异常栈信息数据。</p>
<p>④直接从当前执行的异常点干掉当前程序。</p>
<p>⑤后续代码没有机会执行了，因为程序已经死亡。</p>
<h4 id="编译时异常的处理机制"><a href="#编译时异常的处理机制" class="headerlink" title="编译时异常的处理机制"></a>编译时异常的处理机制</h4><p>编译时异常的处理形式有三种：</p>
<p>出现异常直接抛出去给调用者，调用者也继续抛出去。</p>
<p>出现异常自己捕获处理，不麻烦别人。</p>
<p>前两者结合，出现异常直接抛出去给调用者，调用者捕获处理。</p>
<p>异常处理方式1 —— throws</p>
<p>throws：用在方法上，可以将方法内部出现的异常抛出去给本方法的调用者处理。这种方式并不好，发生异常的方法自己不处理异常，如果异常最终抛出去给虚拟机将引起程序死亡。</p>
<p>异常处理方式2 —— try…catch…;</p>
<p>监视捕获异常，用在方法内部，可以将方法内部出现的异常直接捕获处理。</p>
<p>这种方式还可以，发生异常的方法自己独立完成异常的处理，程序可以继续往下执行。</p>
<p>异常处理方式3 ——前两者结合</p>
<p>方法直接将异通过throws抛出去给调用者</p>
<p>调用者收到异常后直接捕获处理。</p>
<h4 id="运行时异常的处理机制"><a href="#运行时异常的处理机制" class="headerlink" title="运行时异常的处理机制"></a>运行时异常的处理机制</h4><p>运行时异常的处理形式</p>
<p>按照规范建议还是处理：建议在最外层调用处集中捕获处理即可。</p>
<p>运行时异常编译阶段不会出错，是运行时才可能出错的，所以编译阶段不处理也可以。</p>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>自定义异常的必要？</p>
<p>Java无法为这个世界上全部的问题提供异常类。</p>
<p>如果企业想通过异常的方式来管理自己的某个业务问题，就需要自定义异常类了。自定义异常的好处：</p>
<p>可以使用异常的机制管理业务问题，如提醒程序员注意。</p>
<p>同时一旦出现bug，可以用异常的形式清晰的指出出错的地方。</p>
<p>自定义异常的分类</p>
<p>1、自定义编译时异常</p>
<p>定义一个异常类继承Exception.</p>
<p>重写构造器。</p>
<p>在出现异常的地方用throw new自定义对象抛出，作用：编译时异常是编译阶段就报错，提醒更加强烈，一定需要处理！！</p>
<p>2、自定义运行时异常定义一个异常类继承RuntimeException.重写构造器。</p>
<p>在出现异常的地方用throw new自定义对象抛出!作用：提醒不强烈，编译阶段不报错！！运行时才可能出现！！</p>
<h3 id="二十-日志技术"><a href="#二十-日志技术" class="headerlink" title="二十.日志技术"></a>二十.日志技术</h3><p>用来记录程序运行过程中的信息，并可以进行永久存储。</p>
<p>日志接口：一些规范，提供给日志的实现框架设计的标准。包括JCL和s1f4j</p>
<p>日志框架：牛人或者第三方公司已经做好的实现代码，后来者直接可以拿去使用。常见JUL和logback</p>
<h4 id="Logback日志框架"><a href="#Logback日志框架" class="headerlink" title="Logback日志框架"></a>Logback日志框架</h4><p>官方网站：<a target="_blank" rel="noopener" href="https://logback.qos.ch/index.htmlLogback">https://logback.qos.ch/index.htmlLogback</a></p>
<p>日志框架分为以下模块：</p>
<p>logback-core：该模块为其他两个模块提供基础代码。（必须有）</p>
<p>logback-classic：完整实现了slf4j API的模块。（必须有）</p>
<p>logback-access模块与Tomcat和Jetty等Servlet容器集成，以提供HTTP访问日志功能（可选模块，以后接触）</p>
<p>想使用Logback日志框架，至少需要在项目中整合如下三个模块：</p>
<p>slf4j-api：日志接口</p>
<p>logback-core：基础模块</p>
<p>logback-classic：功能模块，它完整实现了slf4j API</p>
<p>实现步骤：</p>
<p>①：导入Logback框架到项目中去。在项目下新建文件夹lib，导入Logback的jar包到该文件夹下</p>
<p>②：将存放jar文件的lib文件夹添加到项目依赖库中去。</p>
<p>③：将Logback的核心配置文件logback.xml直接拷贝到src目录下（必须是src下）。</p>
<p>④：创建Logback框架提供的Logger日志对象，后续使用其方法记录系统的日志信息。</p>
<p><code>public static final LoggerLOGGER= LoggerFactory.getLogger(“类名&quot;);</code></p>
<p>对Logback日志框架的控制，都是通过核心配置文件logback.xml来实现的</p>
<p>Logback日志输出位置、格式设置：</p>
<p>通过logback.xml中的    <code>&lt;append&gt;</code>标签可以设置输出位置。</p>
<p>通常可以设置2个日志输出位置：一个是控制台、一个是系统文件中</p>
<p>日志级别：</p>
<p>ALL和OFF分别是打开、及关闭全部日志信息。</p>
<p>除此之外，日志级别还有：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR ;</p>
<p>默认级别是DEBUG，对应其方法</p>
<p>作用：当在logback.xml文件中设置了某种日志级别后，系统将只输出当前级别，以及高于当前级别的日志。</p>
<h3 id="二十一-File类的使用"><a href="#二十一-File类的使用" class="headerlink" title="二十一.File类的使用"></a>二十一.File类的使用</h3><h4 id="创建File对象"><a href="#创建File对象" class="headerlink" title="创建File对象"></a>创建File对象</h4><p>File类在java.io.File包下。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public File(Stringpathname)</td>
<td>根据文件路径创建文件对象</td>
</tr>
<tr>
<td>public File(Stringparent,Stringchild)</td>
<td>根据父路径名字符串和子路径名字符串创建文件对象</td>
</tr>
<tr>
<td>public File(Fileparent,Stringchild)</td>
<td>根据父路径对应文件对象和子路径名字符串创建文件对象</td>
</tr>
</tbody></table>
<h4 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h4><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean isDirectory()</td>
<td>判断此路径名表示的File是否为文件夹</td>
</tr>
<tr>
<td>public boolean isFile()</td>
<td>判断此路径名表示的File是否为文件</td>
</tr>
<tr>
<td>public boolean exists()</td>
<td>判断此路径名表示的File是否存在</td>
</tr>
<tr>
<td>public long length()</td>
<td>返回文件的大小（字节数量）</td>
</tr>
<tr>
<td>public String getAbsolutePath()</td>
<td>返回文件的绝对路径</td>
</tr>
<tr>
<td>public String getPath()</td>
<td>返回定义文件时使用的路径</td>
</tr>
<tr>
<td>public String getName()</td>
<td>返回文件的名称，带后缀</td>
</tr>
<tr>
<td>public long lastModified()</td>
<td>返回文件的最后修改时间（时间毫秒值）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean createNewFile()</td>
<td>创建一个新的空的文件</td>
</tr>
<tr>
<td>public boolean mkdir()</td>
<td>只能创建一级文件夹</td>
</tr>
<tr>
<td>public boolean mkdirs()</td>
<td>可以创建多级文件夹</td>
</tr>
<tr>
<td>public boolean delete()</td>
<td>删除由此抽象路径名表示的文件或空文件夹</td>
</tr>
</tbody></table>
<p>delete方法默认只能删除文件和空文件夹，delete方法直接删除不走回收站</p>
<p>若文件不存在则创建成功，若文件已经存在则失败</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String[] list()</td>
<td>获取当前目录下所有的”一级文件名称”到一个字符串数组中去返回。</td>
</tr>
<tr>
<td>public File[] listFiles()(常用)</td>
<td>获取当前目录下所有的”一级文件对象”到一个文件对象数组中去返回（重点）</td>
</tr>
</tbody></table>
<h3 id="二十二-字符编码"><a href="#二十二-字符编码" class="headerlink" title="二十二.字符编码"></a>二十二.字符编码</h3><p>字符集（Character Set）是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同，常见字符集有：</p>
<h4 id="ASCII字符集"><a href="#ASCII字符集" class="headerlink" title="ASCII字符集"></a>ASCII字符集</h4><p>ASCII(American Standard Code for Information Interchange，美国信息交换标准代码)：包括了数字、英文、符号</p>
<p>使用1个字节存储一个字符，一个字节是8位，总共可以表示128个字符信息，对于表示英文、数字来说是够用的</p>
<h4 id="GBK字符集"><a href="#GBK字符集" class="headerlink" title="GBK字符集"></a>GBK字符集</h4><p>GBK是中国的码表，包含了几万个汉字等字符，同时也要兼容ASCII编码，</p>
<p>GBK编码中一个中文字符一般以两个字节的形式存储。</p>
<h4 id="Unicode（UTF-8）"><a href="#Unicode（UTF-8）" class="headerlink" title="Unicode（UTF-8）"></a>Unicode（UTF-8）</h4><p>统一码，也叫万国码。是计算机科学领域里的一项业界标准。</p>
<p>UTF-8是Unicode的一种常见编码方式。</p>
<p>UTF-8编码后一个中文一般以三个字节的形式存储，同时也要兼容ASCII编码表。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>byte[] getBytes()</td>
<td>使用平台的默认字符集将该String编码为一系列字节，将结果存储到新的字节数组中</td>
</tr>
<tr>
<td>byte[] getBytes(StringcharsetName)</td>
<td>使用指定的字符集将该String编码为一系列字节，将结果存储到新的字节数组中</td>
</tr>
<tr>
<td>String(byte[]bytes)</td>
<td>通过使用平台的默认字符集解码指定的字节数组来构造新的String</td>
</tr>
<tr>
<td>String(byte[]bytes,StringcharsetName)</td>
<td>通过指定的字符集解码指定的字节数组来构造新的String</td>
</tr>
</tbody></table>
<h3 id="二十三-IO流"><a href="#二十三-IO流" class="headerlink" title="二十三.IO流"></a>二十三.IO流</h3><p><img src="/2022/11/22/JAVA/IO%E6%B5%81.PNG"></p>
<p>IO流概述</p>
<p>I表示intput，把硬盘文件中的数据读入到内存的过程，称之输入，负责读。</p>
<p>O表示output，把内存中的数据写出到硬盘文件的过程，称之输出，负责写。</p>
<h4 id="字节输入流："><a href="#字节输入流：" class="headerlink" title="字节输入流："></a>字节输入流：</h4><p>以内存为基准，来自磁盘文件/网络中的数据以字节的形式读入到内存中去的流称为字节输入流。</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public FileInputStream(File file)</td>
<td>创建字节输入流管道与源文件对象接通</td>
</tr>
<tr>
<td>public FileInputStream(String pathname)</td>
<td>创建字节输入流管道与源文件路径接通</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public byte[] readAllBytes() throws IOException</td>
<td>直接将当前字节输入流对应的文件对象的字节数据装到一个字节数组返回</td>
</tr>
<tr>
<td>public int read()</td>
<td>每次读取一个字节返回，如果字节已经没有可读的返回-1</td>
</tr>
<tr>
<td>public int read(byte[] buffer)</td>
<td>每次读取一个字节数组返回，如果字节已经没有可读的返回-1</td>
</tr>
</tbody></table>
<h4 id="字节输出流："><a href="#字节输出流：" class="headerlink" title="字节输出流："></a>字节输出流：</h4><p>以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流称为字节输出流。</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>publicFileOutputStream(Filefile)</td>
<td>创建字节输出流管道与源文件对象接通</td>
</tr>
<tr>
<td>publicFileOutputStream(Filefile，booleanappend)</td>
<td>创建字节输出流管道与源文件对象接通，可追加数据</td>
</tr>
<tr>
<td>publicFileOutputStream(Stringfilepath)</td>
<td>创建字节输出流管道与源文件路径接通</td>
</tr>
<tr>
<td>publicFileOutputStream(Stringfilepath，booleanappend)</td>
<td>创建字节输出流管道与源文件路径接通，可追加数据</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>publicvoidwrite(inta)</td>
<td>写一个字节出去</td>
</tr>
<tr>
<td>publicvoidwrite(byte[]buffer)</td>
<td>写一个字节数组出去</td>
</tr>
<tr>
<td>publicvoidwrite(byte[]buffer,intpos,intlen)</td>
<td>写一个字节数组的一部分出去。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>flush()</td>
<td>刷新流，还可以继续写数据</td>
</tr>
<tr>
<td>close()</td>
<td>关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据</td>
</tr>
</tbody></table>
<p>字节输出流如何实现写出去的数据能换行</p>
<p><code>os.write(“\r\n”.getBytes())</code></p>
<h4 id="字符输入流："><a href="#字符输入流：" class="headerlink" title="字符输入流："></a>字符输入流：</h4><p>以内存为基准，来自磁盘文件/网络中的数据以字符的形式读入到内存中去的流称为字符输入流。</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public FileReader(File file)</td>
<td>创建字符输入流管道与源文件对象接通</td>
</tr>
<tr>
<td>public FileReader(String pathname)</td>
<td>创建字符输入流管道与源文件路径接通</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int read()</td>
<td>每次读取一个字符返回，如果字符已经没有可读的返回-1</td>
</tr>
<tr>
<td>public int read(char[] buffer)</td>
<td>每次读取一个字符数组，返回读取的字符个数，如果字符已经没有可读的返回-1</td>
</tr>
</tbody></table>
<h4 id="字符输出流："><a href="#字符输出流：" class="headerlink" title="字符输出流："></a>字符输出流：</h4><p>以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流称为字符输出流。磁盘内存</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public FileWriter(File file)</td>
<td>创建字符输出流管道与源文件对象接通</td>
</tr>
<tr>
<td>public FileWriter(File file，boolean append)</td>
<td>创建字符输出流管道与源文件对象接通，可追加数据</td>
</tr>
<tr>
<td>public FileWriter(String filepath)</td>
<td>创建字符输出流管道与源文件路径接通</td>
</tr>
<tr>
<td>public FileWriter(String filepath，boolean append)</td>
<td>创建字符输出流管道与源文件路径接通，可追加数据</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int c)</td>
<td>写一个字符</td>
</tr>
<tr>
<td>void write(char[] cbuf)</td>
<td>写入一个字符数组</td>
</tr>
<tr>
<td>void write(char[] cbuf, int off, int len)</td>
<td>写入字符数组的一部分</td>
</tr>
<tr>
<td>void write(String str)</td>
<td>写一个字符串</td>
</tr>
<tr>
<td>void write(String str, int off, int len)</td>
<td>写一个字符串的一部分</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>flush()</td>
<td>刷新流，还可以继续写数据</td>
</tr>
<tr>
<td>close()</td>
<td>关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据</td>
</tr>
</tbody></table>
<h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><p>缓冲流概述</p>
<p>缓冲流也称为高效流、或者高级流。之前学习的字节流可以称为原始流。</p>
<p>作用：缓冲流自带缓冲区、可以提高原始字节流、字符流读写数据的性能</p>
<h5 id="字节输入和字节输出缓冲流"><a href="#字节输入和字节输出缓冲流" class="headerlink" title="字节输入和字节输出缓冲流"></a>字节输入和字节输出缓冲流</h5><table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public BuferedInputStream(InputStream is)</td>
<td>可以把低级的字节输入流包装成一个高级的缓冲字节输入流管道，从而提高字节输入流读数据的性能</td>
</tr>
<tr>
<td>public BuferedOutputStream(OutputStream os)</td>
<td>可以把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能</td>
</tr>
</tbody></table>
<h5 id="字符输入缓冲流"><a href="#字符输入缓冲流" class="headerlink" title="字符输入缓冲流"></a>字符输入缓冲流</h5><table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public BufferedReader(Reader r)</td>
<td>可以把低级的字符输入流包装成一个高级的缓冲字符输入流管道，从而提高字符输入流读数据的性能</td>
</tr>
</tbody></table>
<p>新增功能：</p>
<p><code>public String readLine()</code>读取一行数据返回，如果读取没有完毕，无行可读返回null</p>
<h5 id="字符输出缓冲流"><a href="#字符输出缓冲流" class="headerlink" title="字符输出缓冲流"></a>字符输出缓冲流</h5><table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public BuferedWriter(Writer w)</td>
<td>可以把低级的字符输出流包装成一个高级的缓冲字符输出流管道，从而提高字符输出流写数据的性能</td>
</tr>
</tbody></table>
<p>新增功能</p>
<p><code>public void newLine()</code>换行操作</p>
<h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><h5 id="字符输入转换流"><a href="#字符输入转换流" class="headerlink" title="字符输入转换流"></a>字符输入转换流</h5><p>字符输入转换流：InputStreamReader，可以把原始的字节流按照指定编码转换成字符输入流。</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public InputStreamReader(InputStream is)</td>
<td>可以把原始的字节流按照代码默认编码转换成字符输入流。几乎不用，与默认的FileReader一样。</td>
</tr>
<tr>
<td>public InputStreamReader(InputStream is，String charset)</td>
<td>可以把原始的字节流按照指定编码转换成字符输入流，这样字符流中的字符就不乱码了(重点)</td>
</tr>
</tbody></table>
<h5 id="字符输出转换流"><a href="#字符输出转换流" class="headerlink" title="字符输出转换流"></a>字符输出转换流</h5><p>字符输入转换流：OutputStreamWriter，可以把字节输出流按照指定编码转换成字符输出流。</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public OutputStreamWriter(OutputStream os)</td>
<td>可以把原始的字节输出流按照代码默认编码转换成字符输出流。几乎不用。</td>
</tr>
<tr>
<td>public OutputStreamWriter(OutputStream os，Stringcharset)</td>
<td>可以把原始的字节输出流按照指定编码转换成字符输出流(重点)</td>
</tr>
</tbody></table>
<h4 id="序列化对象"><a href="#序列化对象" class="headerlink" title="序列化对象"></a>序列化对象</h4><h5 id="对象序列化："><a href="#对象序列化：" class="headerlink" title="对象序列化："></a>对象序列化：</h5><p>使用到的流是对象字节输出流：ObjectOutputStream</p>
<p>构造器：<code>public ObjectOutputStream(OutputStream out)</code>把低级字节输出流包装成高级的对象</p>
<p>字节输出流方法<code>public final void writeObject(Object obj)</code>把对象写出去到对象序列化流的文件中去</p>
<h5 id="对象反序列化："><a href="#对象反序列化：" class="headerlink" title="对象反序列化："></a>对象反序列化：</h5><p>使用到的流是对象字节输入流：ObjectInputStream</p>
<p>作用：以内存为基准，把存储到磁盘文件中去的对象数据恢复成内存中的对象，称为对象反序列化。</p>
<p>构造器说明<code>public ObjectInputStream(InputStream out)</code>把低级字节输如流包装成高级的对象字节</p>
<p>输入流方法名称说明<code>public Object readObject()</code>把存储到磁盘文件中去的对象数据恢复成内存中的对象返回</p>
<h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4><p>作用：打印流可以实现方便、高效的打印数据到文件中去。</p>
<p>打印流一般是指：PrintStream，PrintWriter两个类。</p>
<p>可以实现打印什么数据就是什么数据，例如打印整数97写出去就是97，打印boolean的true，写出去就是true。</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public PrintStream(OutputStream os)</td>
<td>打印流直接通向字节输出流管道</td>
</tr>
<tr>
<td>public PrintStream(Filef)</td>
<td>打印流直接通向文件对象</td>
</tr>
<tr>
<td>public PrintStream(String filepath)</td>
<td>打印流直接通向文件路径</td>
</tr>
</tbody></table>
<p>方法说明<code>public void print(Xxx xx)</code>打印任意类型的数据出去</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public PrintWriter(OutputStream os)</td>
<td>打印流直接通向字节输出流管道</td>
</tr>
<tr>
<td>public PrintWriter (Writer w)</td>
<td>打印流直接通向字符输出流管道</td>
</tr>
<tr>
<td>public PrintWriter (Filef)</td>
<td>打印流直接通向文件对象</td>
</tr>
<tr>
<td>public PrintWriter (String filepath)</td>
<td>打印流直接通向文件路径</td>
</tr>
</tbody></table>
<p>方法说明<code>public void print(Xxx xx)</code>打印任意类型的数据出去</p>
<h4 id="输出语句重定向"><a href="#输出语句重定向" class="headerlink" title="输出语句重定向"></a>输出语句重定向</h4><p>属于打印流的一种应用，可以把输出语句的打印位置改到文件。</p>
<p><code>PrintStream ps = new PrintStream(&quot;文件地址&quot;)</code></p>
<p><code>System.setOut(ps);</code></p>
<p>可以改变<code>System.out.println</code>的打印位置</p>
<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><p>Map接口下，HashMap实现类下的类；</p>
<p>Properties核心作用：</p>
<p>Properties代表的是一个属性文件，可以把自己对象中的键值对信息存入到一个属性文件中去。</p>
<p>属性文件：后缀是.properties结尾的文件,里面的内容都是key=value，后续做系统配置信息的。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void load(InputStream inStream）</td>
<td>从输入字节流读取属性列表（键和元素对）</td>
</tr>
<tr>
<td>void load(Reader reader)</td>
<td>从输入字符流读取属性列表（键和元素对）</td>
</tr>
<tr>
<td>void store(OutputStream out, String comments)</td>
<td>将此属性列表（键和元素对）写入此Properties表中，以适合于使用load(InputStream)方法的格式写入输出字节流</td>
</tr>
<tr>
<td>public Object setProperty(String key, String value)</td>
<td>保存键值对（put）</td>
</tr>
<tr>
<td>void store(Writer writer, String comments)</td>
<td>将此属性列表（键和元素对）写入此Properties表中，以适合使用load(Reader)方法的格式写入输出字符流</td>
</tr>
<tr>
<td>public String getProperty(String key)</td>
<td>使用此属性列表中指定的键搜索属性值(get)</td>
</tr>
<tr>
<td>public Set<String> stringPropertyNames()</td>
<td>所有键的名称的集合(keySet())</td>
</tr>
</tbody></table>
<h4 id="IO框架"><a href="#IO框架" class="headerlink" title="IO框架"></a>IO框架</h4><h5 id="commons-io"><a href="#commons-io" class="headerlink" title="commons-io"></a>commons-io</h5><p>commons-io是apache开源基金组织提供的一组有关IO操作的类库，可以提高IO功能开发的效率。</p>
<p>commons-io工具包提供了很多有关io操作的类。有两个主要的类FileUtils, IOUtils</p>
<p>FileUtils主要有如下方法:</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String readFileToString(File file, String encoding)</td>
<td>读取文件中的数据,返回字符串</td>
</tr>
<tr>
<td>void copyFile(File srcFile, File destFile)</td>
<td>复制文件。</td>
</tr>
<tr>
<td>void copyDirectoryToDirectory(File srcDir, FiledestDir)</td>
<td>复制文件夹。</td>
</tr>
</tbody></table>
<h3 id="二十四-线程"><a href="#二十四-线程" class="headerlink" title="二十四.线程"></a>二十四.线程</h3><p>线程（thread）是一个程序内部的一个执行路径</p>
<p>main方法就是一个执行路径</p>
<p>一个程序一个执行路径被称为单线程</p>
<p>多线程是指从软硬件上实现多条执行流程的技术。</p>
<h4 id="多线程的创建"><a href="#多线程的创建" class="headerlink" title="多线程的创建"></a>多线程的创建</h4><h5 id="1-thread类"><a href="#1-thread类" class="headerlink" title="1.thread类"></a>1.thread类</h5><p>Java是通过java.lang.Thread类来代表线程的。</p>
<p>按照面向对象的思想，Thread类应该提供了实现多线程的方式。</p>
<p>①定义一个子类MyThread继承线程类java.lang.Thread，重写run()方法</p>
<p>②创建MyThread类的对象</p>
<p>③调用线程对象的start()方法启动线程（启动后还是执行run方法的）</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Thread(String name)</td>
<td>可以为当前线程指定名称</td>
</tr>
<tr>
<td>public Thread(Runnable target)</td>
<td>封装Runnable对象成为线程对象</td>
</tr>
<tr>
<td>public Thread(Runnable target，String name )</td>
<td>封装Runnable对象成为线程对象，并指定线程名称</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String getName(）</td>
<td>获取当前线程的名称，默认线程名称是Thread-索引</td>
</tr>
<tr>
<td>void setName(String name)</td>
<td>设置线程名称</td>
</tr>
<tr>
<td>public static Thread currentThread()</td>
<td>返回对当前正在执行的线程对象的引用</td>
</tr>
<tr>
<td>public static void sleep(long time)</td>
<td>让线程休眠指定的时间，单位为毫秒。</td>
</tr>
<tr>
<td>public void run()</td>
<td>线程任务方法</td>
</tr>
<tr>
<td>public void start()</td>
<td>线程启动方法</td>
</tr>
</tbody></table>
<p>注意：</p>
<p>（如果直接调用run方法，则是单线程）</p>
<p>把主线程任务放在子线程之前，这样主线程一直是先跑完的，相当于是一个单线程的效果了。</p>
<p>优点：编码简单</p>
<p>缺点：线程类已经继承Thread，无法继承其他类，不利于扩展。</p>
<h5 id="2-runnable接口"><a href="#2-runnable接口" class="headerlink" title="2.runnable接口"></a>2.runnable接口</h5><p>①定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法</p>
<p>②创建MyRunnable任务对象</p>
<p>③把MyRunnable任务对象交给Thread处理。</p>
<p>④调用线程对象的start()方法启动线程</p>
<p>（可以创建Runnable的匿名内部类对象。）</p>
<p>优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。</p>
<p>缺点：编程多一层对象包装，如果线程有执行结果是不可以直接返回的。</p>
<h5 id="3-Callable接口"><a href="#3-Callable接口" class="headerlink" title="3.Callable接口"></a>3.Callable接口</h5><p>①、得到任务对象</p>
<p>1.定义类实现Callable接口，重写call方法，封装要做的事情。</p>
<p>2.用FutureTask把Callable对象封装成线程任务对象。</p>
<p>②、把线程任务对象交给Thread处理。</p>
<p>③、调用Thread的start方法启动线程，执行任务</p>
<p>④、线程执行完毕后、通过FutureTask的get方法去获取任务执行的结果。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public FutureTask&lt;&gt;(Callable call)</td>
<td>把Callable对象封装成FutureTask对象。</td>
</tr>
<tr>
<td>public V get() throws Exception</td>
<td>获取线程执行call方法返回的结果。</td>
</tr>
</tbody></table>
<p>优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。</p>
<p>可以在线程执行完毕后去获取线程执行的结果。</p>
<p>缺点：编码复杂一点。</p>
<h4 id="线程安全和同步"><a href="#线程安全和同步" class="headerlink" title="线程安全和同步"></a>线程安全和同步</h4><p>多个线程同时操作同一个共享资源的时候可能会出现业务安全问题，称为线程安全问题。</p>
<p>线程同步的核心思想是加锁，把共享资源进行上锁，每次只能一个线程进入访问完毕以后解锁，然后其他线程才能进来。</p>
<h5 id="方式一：同步代码块"><a href="#方式一：同步代码块" class="headerlink" title="方式一：同步代码块"></a>方式一：同步代码块</h5><p>把出现线程安全问题的核心代码给上锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(同步锁对象) &#123;</span><br><span class="line">操作共享资源的代码(核心代码)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理论上：锁对象只要对于当前同时执行的线程来说是同一个对象即可。</p>
<p>规范上：建议使用共享资源作为锁对象。</p>
<p>对于实例方法建议使用this作为锁对象。</p>
<p>对于静态方法建议使用字节码（类名.class）对象作为锁对象</p>
<h5 id="方式二：同步方法"><a href="#方式二：同步方法" class="headerlink" title="方式二：同步方法"></a>方式二：同步方法</h5><p>把出现线程安全问题的核心方法给上锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修饰符 synchronized 返回值类型 方法名称(形参列表) </span><br><span class="line">&#123;操作共享资源的代码&#125;</span><br></pre></td></tr></table></figure>

<p>同步方法其实底层也是有隐式锁对象的，只是锁的范围是整个方法代码。</p>
<p>如果方法是实例方法：同步方法默认用this作为的锁对象。但是代码要高度面向对象！</p>
<p>如果方法是静态方法：同步方法默认用类名.class作为的锁对象。</p>
<h5 id="方式三：Lock锁"><a href="#方式三：Lock锁" class="headerlink" title="方式三：Lock锁"></a>方式三：Lock锁</h5><p>构造方法 <code>public ReentrantLock()  获得Lock锁的实现类对象</code></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void lock()</td>
<td>获得锁</td>
</tr>
<tr>
<td>void unlock()</td>
<td>释放锁</td>
</tr>
</tbody></table>
<h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h4><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void wait()</td>
<td>当前线程等待，直到另一个线程调用notify()或notifyAll()唤醒自己</td>
</tr>
<tr>
<td>void notify()</td>
<td>唤醒正在等待对象监视器(锁对象)的单个线程</td>
</tr>
<tr>
<td>void notifyAll()</td>
<td>唤醒正在等待对象监视器(锁对象)的所有线程</td>
</tr>
</tbody></table>
<p>上述方法应该使用当前同步锁对象进行调用。</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><h5 id="线程池概述"><a href="#线程池概述" class="headerlink" title="线程池概述"></a>线程池概述</h5><p>线程池就是一个可以复用线程的技术。</p>
<p>如果用户每发起一个请求，后台就创建一个新线程来处理，下次新任务来了又要创建新线程，而创建新线程的开销是很大的，这样会严重影响系统的性能。</p>
<h5 id="线程池实现的API、参数说明"><a href="#线程池实现的API、参数说明" class="headerlink" title="线程池实现的API、参数说明"></a>线程池实现的API、参数说明</h5><p>方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象</p>
<p>方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">int maximumPoolSize,</span><br><span class="line">long keepAliveTime,</span><br><span class="line">TimeUnit unit,</span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">ThreadFactory threadFactory,</span><br><span class="line">RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>

<p>参数一：指定线程池的线程数量（核心线程）：corePoolSize                        不能小于0</p>
<p>参数二：指定线程池可支持的最大线程数：maximumPoolSize                        最大数量 &gt;= 核心线程数量l</p>
<p>参数三：指定临时线程的最大存活时间：keepAliveTime                                不能小于0</p>
<p>参数四：指定存活时间的单位(秒、分、时、天)：unit                                时间单位</p>
<p>参数五：指定任务队列：workQueue                                                                            不能为null</p>
<p>参数六：指定用哪个线程工厂创建线程：threadFactory                                    不能为null</p>
<p>参数七：指定线程忙，任务满的时候，新任务来了怎么办：handler                不能为nul</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void execute(Runnable command)</td>
<td>执行任务/命令，没有返回值，一般用来执行Runnable任务</td>
</tr>
<tr>
<td>Future<T> submit(Callable<T> task)</td>
<td>执行任务，返回未来任务对象获取线程结果，一般拿来执行Callable任务</td>
</tr>
<tr>
<td>void shutdown()</td>
<td>等任务执行完毕后关闭线程池</td>
</tr>
<tr>
<td>List<Runnable>shutdownNow()</td>
<td>立刻关闭，停止正在执行的任务，并返回队列中未执行的任务</td>
</tr>
</tbody></table>
<p>：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>详解</th>
</tr>
</thead>
<tbody><tr>
<td>ThreadPoolExecutor.AbortPolicy</td>
<td>丢弃任务并抛出RejectedExecutionException异常。是默认的策略</td>
</tr>
<tr>
<td>ThreadPoolExecutor.DiscardPolicy</td>
<td>丢弃任务，但是不抛出异常 这是不推荐的做法</td>
</tr>
<tr>
<td>ThreadPoolExecutor.DiscardOldestPolicy</td>
<td>抛弃队列中等待最久的任务然后把当前任务加入队列中</td>
</tr>
<tr>
<td>ThreadPoolExecutor.CallerRunsPolicy</td>
<td>由主线程负责调用任务的run()方法从而绕过线程池直接执行</td>
</tr>
</tbody></table>
<h5 id="Executors工具类实现线程池"><a href="#Executors工具类实现线程池" class="headerlink" title="Executors工具类实现线程池"></a>Executors工具类实现线程池</h5><p><strong>Executors</strong> <strong>得到线程池对象的常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newCachedThreadPool()</td>
<td>线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了一段时间则会被回收掉。</td>
</tr>
<tr>
<td>public static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newFixedThreadPool(int nThreads)</td>
<td>创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。</td>
</tr>
<tr>
<td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newSingleThreadExecutor ()</td>
<td>创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程。</td>
</tr>
<tr>
<td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ScheduledExecutorService.html">ScheduledExecutorService</a> newScheduledThreadPool(int corePoolSize)</td>
<td>创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务。</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> <strong>Executors</strong> <strong>的底层其实也是基于线程池的实现类</strong> <strong>ThreadPoolExecutor</strong> <strong>创建线程池对象的。</strong></p>
<p>大型并发系统环境中使用Executors如果不注意可能会出现系统风险。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>存在问题</th>
</tr>
</thead>
<tbody><tr>
<td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newFixedThreadPool(int nThreads)</td>
<td>允许请求的任务队列长度是Integer.MAX_VALUE，可能出现OOM错误（ java.lang.OutOfMemoryError ）</td>
</tr>
<tr>
<td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newSingleThreadExecutor()</td>
<td></td>
</tr>
<tr>
<td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newCachedThreadPool()</td>
<td>创建的线程数量最大上限是Integer.MAX_VALUE，  线程数可能会随着任务1:1增长，也可能出现OOM错误（ java.lang.OutOfMemoryError ）</td>
</tr>
<tr>
<td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ScheduledExecutorService.html">ScheduledExecutorService</a> newScheduledThreadPool(int corePoolSize)</td>
<td></td>
</tr>
</tbody></table>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a><strong>定时器</strong></h4><p>定时器是一种控制任务延时调用，或者周期调用的技术。</p>
<h5 id="方式一：Timer"><a href="#方式一：Timer" class="headerlink" title="方式一：Timer"></a>方式一：Timer</h5><table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  Timer()</td>
<td>创建Timer定时器对象</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void schedule(<a href="file:///D:/course/%E5%9F%BA%E7%A1%80%E9%98%B6%E6%AE%B5/API%E6%96%87%E6%A1%A3/docs/api/java.base/java/util/TimerTask.html">TimerTask</a> task,  long delay, long period)</td>
<td>开启一个定时器，按照计划处理TimerTask任务</td>
</tr>
</tbody></table>
<h5 id="方式二：-ScheduledExecutorService"><a href="#方式二：-ScheduledExecutorService" class="headerlink" title="方式二： ScheduledExecutorService"></a>方式二： ScheduledExecutorService</h5><table>
<thead>
<tr>
<th>Executors的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</td>
<td>得到线程池对象</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>ScheduledExecutorService的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period,                              TimeUnit unit)</td>
<td>周期调度方法</td>
</tr>
</tbody></table>
<p>基于线程池，某个任务的执行情况不会影响其他定时任务的执行。</p>
<h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a><strong>线程的生命周期</strong></h4><table>
<thead>
<tr>
<th>NEW(新建)</th>
<th>线程刚被创建，但是并未启动。</th>
</tr>
</thead>
<tbody><tr>
<td>Runnable(可运行)</td>
<td>线程已经调用了start()等待CPU调度</td>
</tr>
<tr>
<td>Blocked(锁阻塞)</td>
<td>线程在执行的时候未竞争到锁对象，则该线程进入Blocked状态；。</td>
</tr>
<tr>
<td>Waiting(无限等待)</td>
<td>一个线程进入Waiting状态，另一个线程调用notify或者notifyAll方法才能够唤醒</td>
</tr>
<tr>
<td>Timed Waiting(计时等待)</td>
<td>同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。带有超时参数的常用方法有Thread.sleep 、Object.wait。</td>
</tr>
<tr>
<td>Teminated(被终止)</td>
<td>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</td>
</tr>
</tbody></table>
<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><p>网络编程可以让程序与网络上的其他设备中的程序进行数据交互。</p>
<p>常见的通信模式有如下2种形式：Client-Server(CS) 、 Browser/Server(BS)</p>
<h4 id="网络通信三要素"><a href="#网络通信三要素" class="headerlink" title="网络通信三要素"></a><strong>网络通信三要素</strong></h4><h5 id="三要素概述、要素一：IP地址"><a href="#三要素概述、要素一：IP地址" class="headerlink" title="三要素概述、要素一：IP地址"></a>三要素概述、要素一：IP地址</h5><p>设备在网络中的地址，是唯一的标识。</p>
<p>常见的IP分类为：IPv4和IPv6</p>
<p><strong>IP</strong> <strong>地址形式：</strong></p>
<p>公网地址、和私有地址(局域网使用)。</p>
<p>192.168. 开头的就是常见的局域网地址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用。 </p>
<p><strong>IP</strong> <strong>常用命令：</strong></p>
<p>ipconfig：查看本机IP地址</p>
<p>ping IP地址：检查网络是否连通</p>
<p><strong>特殊</strong> <strong>IP</strong> <strong>地址</strong>：</p>
<p>本机IP: 127.0.0.1或者localhost：称为回送地址也可称本地回环地址，只会寻找当前所在本机。</p>
<h5 id="IP地址操作类-InetAddress"><a href="#IP地址操作类-InetAddress" class="headerlink" title="IP地址操作类-InetAddress"></a>IP地址操作类-InetAddress</h5><p>此类表示Internet协议（IP）地址。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/net/InetAddress.html">InetAddress</a> getLocalHost()</td>
<td>返回本主机的地址对象</td>
</tr>
<tr>
<td>public static  InetAddress getByName(String host)</td>
<td>得到指定主机的IP地址对象，参数是域名或者IP地址</td>
</tr>
<tr>
<td>public String  getHostName()</td>
<td>获取此IP地址的主机名</td>
</tr>
<tr>
<td>public String  getHostAddress()</td>
<td>返回IP地址字符串</td>
</tr>
<tr>
<td>public boolean isReachable(int timeout)</td>
<td>在指定毫秒内连通该IP地址对应的主机，连通返回true</td>
</tr>
</tbody></table>
<h5 id="要素二：端口号"><a href="#要素二：端口号" class="headerlink" title="要素二：端口号"></a>要素二：端口号</h5><p>应用程序在设备中唯一的标识。</p>
<p>端口号：标识正在计算机设备上运行的进程（程序），被规定为一个 16 位的二进制，范围是 0~65535</p>
<p><strong>端口类型</strong></p>
<p>周知端口：0~1023，被预先定义的知名应用占用（如：HTTP占用 80，FTP占用21） </p>
<p><strong>注册端口</strong>：1024~49151，分配给用户进程或某些应用程序。（如：Tomcat占 用8080，MySQL占用3306）</p>
<p>动态端口：49152到65535，之所以称为动态端口，是因为它 一般不固定分配某种进程，而是动态分配。</p>
<p><strong>注意：我们自己开发的程序选择注册端口，且一个设备中不能出现两个程序的端口号一样，否则出错。</strong></p>
<h5 id="要素三：协议"><a href="#要素三：协议" class="headerlink" title="要素三：协议"></a>要素三：协议</h5><p>连接和通信数据的规则被称为网络通信协议</p>
<p>数据在网络中传输的规则，常见的协议有UDP协议和TCP协议。</p>
<table>
<thead>
<tr>
<th>OSI参考模型</th>
<th>TCP/IP参考模型</th>
<th>各层对应</th>
<th>面向操作</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>应用层</td>
<td>HTTP、FTP、DNS、SMTP…</td>
<td>应用程序需要关注的：浏览器，邮箱。程序员一般在这一层开发</td>
</tr>
<tr>
<td>表示层</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>会话层</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
<td>TCP、UDP…</td>
<td>选择使用的TCP , UDP协议</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
<td>IP、ICMP…</td>
<td>封装源和目标IP，进行路径选择</td>
</tr>
<tr>
<td>数据链路层</td>
<td>数据链路层+物理</td>
<td>物理寻址、比特流…</td>
<td>物理设备中传输</td>
</tr>
<tr>
<td>物理层</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a><strong>UDP</strong></h4><p>UDP(User Datagram Protocol)：用户数据报协议</p>
<p>UDP是一种无连接、不可靠传输的协议。</p>
<p>将数据源IP、目的地IP和端口封装成数据包，不需要建立连接</p>
<p>每个数据包的大小限制在64KB内</p>
<p>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的 </p>
<p>可以广播发送 ，发送数据结束时无需释放资源，开销小，速度快。</p>
<p><strong>DatagramPacket</strong> <strong>：数据包对象（韭菜盘子）</strong></p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public DatagramPacket(byte[] buf, int  length, InetAddress address,  int port)</td>
<td>创建发送端数据包对象  buf：要发送的内容，字节数组  length：要发送内容的字节长度  address：接收端的IP地址对象  port：接收端的端口号</td>
</tr>
<tr>
<td>public DatagramPacket(byte[] buf, int  length)</td>
<td>创建接收端的数据包对象  buf：用来存储接收的内容  length：能够接收内容的长度</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int getLength()</td>
<td>获得实际接收到的字节个数</td>
</tr>
</tbody></table>
<p><strong>DatagramSocket</strong> <strong>：</strong> <strong>发送端和接收端对象（人）</strong></p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public DatagramSocket()</td>
<td>创建发送端的Socket对象，系统会随机分配一个端口号。</td>
</tr>
<tr>
<td>public DatagramSocket(int port)</td>
<td>创建接收端的Socket对象并指定端口号</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void send(DatagramPacket dp)</td>
<td>发送数据包</td>
</tr>
<tr>
<td>public void receive(DatagramPacket p)</td>
<td>接收数据包</td>
</tr>
</tbody></table>
<p>需求：客户端实现步骤</p>
<p>①创建DatagramSocket对象（发送端对象）           扔韭菜的人</p>
<p>②创建DatagramPacket对象封装需要发送的数据（数据包对象）         韭菜盘子</p>
<p>③使用DatagramSocket对象的send方法传入DatagramPacket对象         开始抛出韭菜</p>
<p>④释放资源</p>
<p>接收端实现步骤</p>
<p>①创建DatagramSocket对象并指定端口（接收端对象）           接韭菜的人</p>
<p>②创建DatagramPacket对象接收数据（数据包对象）         韭菜盘子</p>
<p>③使用DatagramSocket对象的receive方法传入DatagramPacket对象         开始接收韭菜</p>
<p>④释放资源</p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a><strong>TCP</strong></h4><p>TCP(Transmission Control Protocol) ：传输控制协议</p>
<p> TCP是一种面向连接，安全、可靠的传输数据的协议 </p>
<p>传输前，采用“三次握手”方式，点对点通信，是可靠的 </p>
<p> 在连接中可进行大数据量的传输 </p>
<p><strong>注意：在</strong> <strong>java</strong> <strong>中只要是使用</strong> <strong>java.net.Socket</strong> <strong>类实现通信，底层即是使用了</strong> <strong>TCP</strong> <strong>协议</strong></p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Socket(String host , int port)</td>
<td>创建发送端的Socket对象与服务端连接，参数为服务端程序的ip和端口。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>OutputStream getOutputStream()</td>
<td>获得字节输出流对象</td>
</tr>
<tr>
<td>InputStream getInputStream()</td>
<td>获得字节输入流对象</td>
</tr>
</tbody></table>
<p>需求：客户端实现步骤</p>
<p>①创建客户端的Socket对象，请求与服务端的连接。</p>
<p>②使用socket对象调用getOutputStream()方法得到字节输出流。</p>
<p>③使用字节输出流完成数据的发送。</p>
<p>④释放资源：关闭socket管道。</p>
<p><strong>ServerS</strong> <strong>ocket</strong> <strong>(</strong> <strong>服务端</strong> <strong>)</strong></p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public ServerSocket(int port)</td>
<td>注册服务端端口</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Socket accept()</td>
<td>等待接收客户端的Socket通信连接  连接成功返回Socket对象与客户端建立端到端通信</td>
</tr>
</tbody></table>
<p>需求：服务端实现步骤</p>
<p>①创建ServerSocket对象，注册服务端端口。</p>
<p>②调用ServerSocket对象的accept()方法，等待客户端的连接，并得到Socket管道对象。</p>
<p>③通过Socket对象调用getInputStream()方法得到字节输入流、完成数据的接收。</p>
<p>④释放资源：关闭socket管道</p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试就是针对最小的功能单元编写测试代码，Java程序最小的功能单元是方法，因此，单元测试就是针对Java方法的测试，进而检查方法的正确性。</p>
<p><strong>Junit</strong> <strong>单元测试框架</strong></p>
<p>JUnit是使用Java语言实现的单元测试框架，它是开源的，Java开发者都应当学习并使用JUnit编写单元测试。</p>
<p>此外，几乎所有的IDE工具都集成了JUnit，这样我们就可以直接在IDE中编写并运行JUnit测试，JUnit目前最新版本是5。</p>
<p><strong>JUnit</strong> <strong>优点</strong></p>
<p>JUnit可以灵活的选择执行哪些测试方法，可以一键执行全部测试方法。</p>
<p> Junit可以生成全部方法的测试报告。</p>
<p> 单元测试中的某个方法测试失败了，不会影响其他测试方法的测试。</p>
<p>需求：使用单元测试进行业务方法预期结果、正确性测试的快速入门</p>
<p>①将JUnit的jar包导入到项目中</p>
<p>IDEA通常整合好了Junit框架，一般不需要导入。</p>
<p>如果IDEA没有整合好，需要自己手工导入如下2个JUnit的jar包到模块</p>
<p>②编写测试方法：该测试方法必须是公共的无参数无返回值的非静态方法。</p>
<p>③在测试方法上使用@Test注解：标注该方法是一个测试方法</p>
<p>④在测试方法中完成被测试方法的预期正确性测试。</p>
<p>⑤选中测试方法，选择“JUnit运行” ，如果<strong>测试良好</strong>则是<strong>绿色</strong>；如果<strong>测试失败</strong>，则是<strong>红色</strong></p>
<p>4版本</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Test</td>
<td>测试方法</td>
</tr>
<tr>
<td>@Before</td>
<td>用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。</td>
</tr>
<tr>
<td>@After</td>
<td>用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。</td>
</tr>
<tr>
<td>@BeforeClass</td>
<td>用来静态修饰方法，该方法会在所有测试方法之前只执行一次。</td>
</tr>
<tr>
<td>@AfterClass</td>
<td>用来静态修饰方法，该方法会在所有测试方法之后只执行一次。</td>
</tr>
</tbody></table>
<p>5版本</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Test</td>
<td>测试方法</td>
</tr>
<tr>
<td>@BeforeEach</td>
<td>用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。</td>
</tr>
<tr>
<td>@AfterEach</td>
<td>用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。</td>
</tr>
<tr>
<td>@BeforeAll</td>
<td>用来静态修饰方法，该方法会在所有测试方法之前只执行一次。</td>
</tr>
<tr>
<td>@AfterAll</td>
<td>用来静态修饰方法，该方法会在所有测试方法之后只执行一次。</td>
</tr>
</tbody></table>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>反射是指对于任何一个Class类，在”运行的时候”都可以直接得到这个类全部成分。</p>
<p>在运行时,可以直接得到这个类的构造器对象：Constructor</p>
<p>在运行时,可以直接得到这个类的成员变量对象：Field</p>
<p>在运行时,可以直接得到这个类的成员方法对象：Method</p>
<p>这种运行时动态获取类信息以及动态调用类中成分的能力称为Java语言的反射机制。</p>
<p>获取Class类的对象的三种方式</p>
<p><strong>方式一：</strong> <strong>Class c1 =</strong> <strong>Class.forName</strong> <strong>(“</strong> <strong>全类名</strong> <strong>”);</strong></p>
<p><strong>方式二：</strong> <strong>Class c2 =</strong> <strong>类名</strong> <strong>.class</strong></p>
<p><strong>方式三：</strong> <strong>Class c3 =</strong> <strong>对象</strong> <strong>.</strong> <strong>getClass</strong> <strong>();</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Constructor&lt;?&gt;[]  getConstructors()</td>
<td>返回所有构造器对象的数组（只能拿public的）</td>
</tr>
<tr>
<td>Constructor&lt;?&gt;[]  getDeclaredConstructors()</td>
<td>返回所有构造器对象的数组，存在就能拿到</td>
</tr>
<tr>
<td>Constructor<T>  getConstructor(Class&lt;?&gt;…  parameterTypes)</td>
<td>返回单个构造器对象（只能拿public的）</td>
</tr>
<tr>
<td>Constructor<T>  getDeclaredConstructor(Class&lt;?&gt;…  parameterTypes)</td>
<td>返回单个构造器对象，存在就能拿到</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>T newInstance(Object…  initargs)</td>
<td>根据指定的构造器创建对象</td>
</tr>
<tr>
<td>public  void setAccessible(boolean  flag)</td>
<td>设置为true,表示取消访问检查，进行暴力反射</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Field[]  getFields()</td>
<td>返回所有成员变量对象的数组（只能拿public的）</td>
</tr>
<tr>
<td>Field[]  getDeclaredFields()</td>
<td>返回所有成员变量对象的数组，存在就能拿到</td>
</tr>
<tr>
<td>Field  getField(String  name)</td>
<td>返回单个成员变量对象（只能拿public的）</td>
</tr>
<tr>
<td>Field  getDeclaredField(String  name)</td>
<td>返回单个成员变量对象，存在就能拿到</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void  set(Object obj, Object value)：</td>
<td>赋值</td>
</tr>
<tr>
<td>Object  get(Object obj)</td>
<td>获取值。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Method[]  getMethods()</td>
<td>返回所有成员方法对象的数组（只能拿public的）</td>
</tr>
<tr>
<td>Method[]  getDeclaredMethods()</td>
<td>返回所有成员方法对象的数组，存在就能拿到</td>
</tr>
<tr>
<td>Method  getMethod(String  name, Class&lt;?&gt;… parameterTypes)</td>
<td>返回单个成员方法对象（只能拿public的）</td>
</tr>
<tr>
<td>Method  getDeclaredMethod(String  name, Class&lt;?&gt;… parameterTypes)</td>
<td>返回单个成员方法对象，存在就能拿到</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Object invoke(Object obj, Object… args)</td>
<td>运行方法  参数一：用obj对象调用该方法  参数二：调用方法的传递的参数（如果没有就不写）  返回值：方法的返回值（如果没有就不写）</td>
</tr>
</tbody></table>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。</p>
<p>Java 语言中的类、构造器、方法、成员变量、参数等都可以被注解进行标注。</p>
<p>对Java中类、方法、成员变量做标记，然后进行特殊处理，至于到底做何种处理由业务需求来决定。</p>
<p>例如：JUnit框架中，标记了注解@Test的方法就可以被当成测试方法执行，而没有标记的就不能当成测试方法执行。</p>
<p><strong>自定义注解</strong> <strong>—</strong> <strong>格式</strong></p>
<p>自定义注解就是自己做一个注解来使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public @interface 注解名称 &#123;</span><br><span class="line">public 属性类型 属性名() default 默认值 ;</span><br><span class="line">&#125;</span><br><span class="line">特殊属性</span><br><span class="line">value属性，如果只有一个value属性的情况下，使用value属性的时候可以省略value名称不写!!</span><br><span class="line">但是如果有多个属性,  且多个属性没有默认值，那么value名称是不能省略的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>元注解：注解注解的注解。 </p>
<p><strong>元注解有两个：</strong></p>
<p><strong>@Target</strong>: 约束自定义注解只能在哪些地方使用，</p>
<p> TYPE，类，接口</p>
<p> FIELD, 成员变量</p>
<p>METHOD, 成员方法</p>
<p>PARAMETER, 方法参数</p>
<p>CONSTRUCTOR, 构造器</p>
<p>LOCAL_VARIABLE, 局部变量</p>
<p><strong>@Retention</strong>：申明注解的生命周期<br>   SOURCE： 注解只作用在源码阶段，生成的字节码文件中不存在</p>
<p> CLASS： 注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值.</p>
<p> RUNTIME：注解作用在源码阶段，字节码文件阶段，运行阶段（开发常用）</p>
<p>注解的操作中经常需要进行解析，注解的解析就是判断是否存在注解，存在注解就解析出内容。</p>
<p><strong>与注解解析相关的接口</strong></p>
<p>Annotation: 注解的顶级接口，注解都是Annotation类型的对象</p>
<p>AnnotatedElement:该接口定义了与注解解析相关的解析方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Annotation[]  getDeclaredAnnotations()</td>
<td>获得当前对象上使用的所有注解，返回注解数组。</td>
</tr>
<tr>
<td>T getDeclaredAnnotation(Class<T>  annotationClass)</td>
<td>根据注解类型获得对应注解对象</td>
</tr>
<tr>
<td>boolean isAnnotationPresent(Class<Annotation>  annotationClass)</td>
<td>判断当前对象是否使用了指定的注解，如果使用了则返回true，否则false</td>
</tr>
</tbody></table>
<p>所有的类成分Class, Method , Field , Constructor，都实现了AnnotatedElement接口他们都拥有解析注解的能力：</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>代理就是被代理者没有能力或者不愿意去完成某件事情，需要找个人代替自己去完成这件事，动态代理就是用来对业务功能（方法）进行代理的。</p>
<p>关键步骤</p>
<p>必须有接口，实现类要实现接口（代理通常是基于接口实现的）。</p>
<p>创建一个实现类的对象，该对象为业务对象，紧接着为业务对象做一个代理对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyUtil</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getProx</span><span class="params">(T obj)</span></span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(obj.getClass().getClassloader(),obj.getClass().getInterfaces(),<span class="keyword">new</span> <span class="title class_">InvacationMandler</span>()&#123;</span><br><span class="line">        <span class="meta">@Overrid</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Objext proxy,Method method ,Object[] args)</span></span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">Object</span> <span class="variable">rs</span> <span class="operator">=</span> method.invoke(obj,args);     真正执行方法,可以在方法执行前后做文章</span><br><span class="line">            retuen rs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                                          </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String [] args)</span>   &#123;</span><br><span class="line">   <span class="type">Student</span> <span class="variable">t1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Student</span>;</span><br><span class="line">   Student t2=ProxyUtil.getProx(t1);</span><br><span class="line">   通过代理t2调用t1的方法</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><p>XML是可扩展标记语言（eXtensible Markup Language）的缩写，它是是一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据。</p>
<p><strong>XML</strong> <strong>的几个</strong> <strong>特点</strong> <strong>和使用场景</strong></p>
<p>一是纯文本，默认使用UTF-8编码；二是可嵌套；</p>
<p>如果把XML内容存为文件，那么它就是一个XML文件。</p>
<p>XML的使用场景：<strong>XML内容经常</strong> <strong>被当成</strong> <strong>消息</strong> <strong>进行网络</strong> <strong>传输</strong> <strong>，或者作为配置文件用于存储系统的信息。</strong> </p>
<p>文档声明必须是第一行</p>
<p><code>*&lt;?*xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; *?&gt; </code><br>* version：XML默认的版本号码、该属性是必须存在的<br> encoding：本XML文件的编码</p>
<p><strong>XML</strong> <strong>的标签</strong> <strong>(</strong> <strong>元素</strong> <strong>)</strong> <strong>规则</strong></p>
<p>标签由一对尖括号和合法标识符组成: <name></name>，必须存在一个根标签，有且只能有一个。</p>
<p>标签必须成对出现，有开始，有结束: <name></name></p>
<p>特殊的标签可以不成对，但是必须有结束标记，如:<br/></p>
<p>标签中可以定义属性，属性和标签名空格隔开,属性值必须用引号引起来&lt;student id = “1”&gt;</name></p>
<p>标签需要正确的嵌套</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt;    &lt;  小于</span><br><span class="line">&amp;gt;    &gt;  大于</span><br><span class="line">&amp;amp;   &amp;  和号</span><br><span class="line">&amp;apos;  &#x27;  单引号</span><br><span class="line">&amp;quot;  &quot;  引号</span><br><span class="line"></span><br><span class="line">XML文件中可以存在CDATA区: &lt;![CDATA[  …内容… ]]&gt;</span><br></pre></td></tr></table></figure>

<h4 id="XML文档约束方式一-DTD约束"><a href="#XML文档约束方式一-DTD约束" class="headerlink" title="XML文档约束方式一-DTD约束"></a>XML文档约束方式一-DTD约束</h4><p><strong>需求：</strong>利用DTD文档约束，约束一个XML文件的编写。</p>
<p><strong>分析：</strong></p>
<p>①：编写DTD约束文档，后缀必须是.dtd</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT 书架 (书+)&gt;</span><br><span class="line">&lt;!ELEMENT 书 (书名,作者,售价)&gt;</span><br><span class="line">&lt;!ELEMENT 书名 (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT 作者 (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT 售价 (#PCDATA)&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>②：在需要编写的XML文件中导入该DTD约束文档</p>
<p>③：按照约束的规定编写XML文件的内容。</p>
<h4 id="XML文档约束方式二-schema约束"><a href="#XML文档约束方式二-schema约束" class="headerlink" title="XML文档约束方式二-schema约束"></a>XML文档约束方式二-schema约束</h4><p>①：编写schema约束文档，后缀必须是.xsd，具体的形式到代码中观看。</p>
<p>②：在需要编写的XML文件中导入该schema约束文档</p>
<p>③：按照约束内容编写XML文件的标签。</p>
<h4 id="XML解析技术"><a href="#XML解析技术" class="headerlink" title="XML解析技术"></a>XML解析技术</h4><p>使用程序读取XML中的数据</p>
<p><strong>Dom</strong> <strong>常见的解析工具</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>JAXP</td>
<td>SUN公司提供的一套XML的解析的API</td>
</tr>
<tr>
<td>JDOM</td>
<td>JDOM是一个开源项目，它基于树型结构，利用纯JAVA的技术对XML文档实现解析、生成、序列化以及多种操作。</td>
</tr>
<tr>
<td>dom4j</td>
<td>是JDOM的升级品，用来读写XML文件的。具有性能优异、功能强大和极其易使用的特点，它的性能超过sun公司官方的dom  技术，同时它也是一个开放源代码的软件，Hibernate也用它来读写配置文件。</td>
</tr>
<tr>
<td>jsoup</td>
<td>功能强大DOM方式的XML解析开发包，尤其对HTML解析更加方便</td>
</tr>
</tbody></table>
<p>①下载Dom4j框架，官网下载。</p>
<p>②在项目中创建一个文件夹：lib</p>
<p>③将dom4j-2.1.1.jar文件复制到 lib 文件夹</p>
<p>④在jar文件上点右键，选择 Add as Library -&gt; 点击OK</p>
<p>⑤在类中导包使用</p>
<p><strong>Dom4j</strong> <strong>解析</strong> <strong>XML-</strong> <strong>得到</strong> <strong>Document</strong> <strong>对象</strong></p>
<p>SAXReader类</p>
<table>
<thead>
<tr>
<th>构造器/方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public SAXReader()</td>
<td>创建Dom4J的解析器对象</td>
</tr>
<tr>
<td>Document  read(String url)</td>
<td>加载XML文件成为Document对象</td>
</tr>
</tbody></table>
<p>Document类</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Element getRootElement()</td>
<td>获得根元素对象</td>
</tr>
</tbody></table>
<p>SAXReader类</p>
<table>
<thead>
<tr>
<th>构造器/方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public SAXReader()</td>
<td>创建Dom4J的解析器对象</td>
</tr>
<tr>
<td>Document  read(String url)</td>
<td>加载XML文件成为Document对象</td>
</tr>
</tbody></table>
<p>Document类</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Element getRootElement()</td>
<td>获得根元素对象</td>
</tr>
</tbody></table>
<p><strong>Dom4j</strong> <strong>解析</strong> <strong>XML</strong> <strong>的元素、属性、文本</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>List<Element> elements()</td>
<td>得到当前元素下所有子元素</td>
</tr>
<tr>
<td>List<Element>  elements(String name)</td>
<td>得到当前元素下指定名字的子元素返回集合</td>
</tr>
<tr>
<td>Element  element(String name)</td>
<td>得到当前元素下指定名字的子元素,如果有很多名字相同的返回第一个</td>
</tr>
<tr>
<td>String  getName()</td>
<td>得到元素名字</td>
</tr>
<tr>
<td>String attributeValue(String name)</td>
<td>通过属性名直接得到属性值</td>
</tr>
<tr>
<td>String  elementText(子元素名)</td>
<td>得到指定名称的子元素的文本</td>
</tr>
<tr>
<td>String  getText()</td>
<td>得到文本</td>
</tr>
</tbody></table>
<p><strong>XPath</strong> <strong>介绍</strong></p>
<p>XPath在解析XML文档方面提供了一独树一帜的路径思想，更加优雅，高效</p>
<p>XPath使用路径表达式来定位XML文档中的元素节点或属性节点。</p>
<p><strong>示例</strong></p>
<p>/元素/子元素/孙元素</p>
<p>//子元素//孙元素</p>
<p>需求：使用Dom4J把一个XML文件的数据进行解析</p>
<p>分析：</p>
<p>①导入jar包(dom4j和jaxen-1.1.2.jar)，Xpath技术依赖Dom4j技术</p>
<p>②通过dom4j的SAXReader获取Document对象</p>
<p>③利用XPath提供的API,结合XPath的语法完成选取XML文档元素节点进行解析操作。</p>
<p>④Document中与Xpath相关的API如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Node  selectSingleNode(“表达式”)</td>
<td>获取符合表达式的唯一元素</td>
</tr>
<tr>
<td>List<Node> selectNodes(“表达式”)</td>
<td>获取符合表达式的元素集合</td>
</tr>
</tbody></table>
<p><strong>Xpath</strong> <strong>的四大检索方案</strong></p>
<p>绝对路径</p>
<p>采用绝对路径获取从根节点开始逐层的查找/contactList/contact/name节点列表并打印信息</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/根元素/子元素/孙元素</td>
<td>从根元素开始，一级一级向下查找，不能跨级</td>
</tr>
</tbody></table>
<p>相对路径</p>
<p>先得到根节点contactList</p>
<p>再采用相对路径获取下一级contact 节点的name子节点并打印信息</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>./子元素/孙元素</td>
<td>从当前元素开始，一级一级向下查找，不能跨级</td>
</tr>
</tbody></table>
<p>全文检索</p>
<p>直接全文搜索所有的name元素并打印</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>//contact</td>
<td>找contact元素，无论元素在哪里</td>
</tr>
<tr>
<td>//contact/name</td>
<td>找contact，无论在哪一级，但name一定是contact的子节点</td>
</tr>
<tr>
<td>//contact//name</td>
<td>contact无论在哪一种，name只要是contact的子孙元素都可以找到</td>
</tr>
</tbody></table>
<p>属性查找</p>
<p>在全文中搜索属性，或者带属性的元素</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>//@属性名</td>
<td>查找属性对象，无论是哪个元素，只要有这个属性即可。</td>
</tr>
<tr>
<td>//元素[@属性名]</td>
<td>查找元素对象，全文搜索指定元素名和属性名。</td>
</tr>
<tr>
<td>//元素//[@属性名=‘值’]</td>
<td>查找元素对象，全文搜索指定元素名和属性名，并且属性值相等。</td>
</tr>
</tbody></table>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
        <div class="side">
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E7%AC%AC%E4%B8%80%E6%AE%B5%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">一.第一段程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E5%8F%98%E9%87%8F"><span class="toc-number">2.</span> <span class="toc-text">二.变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">三.数据转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%B0%83%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">四.方法的定义与调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.</span> <span class="toc-text">五.选择语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.</span> <span class="toc-text">六.循环语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83-%E6%95%B0%E7%BB%84"><span class="toc-number">7.</span> <span class="toc-text">七.数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">8.</span> <span class="toc-text">八.动态数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">9.</span> <span class="toc-text">九.字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.</span> <span class="toc-text">十.类和对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text">十一.抽象类和抽象方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C-%E8%BD%AC%E5%9E%8B"><span class="toc-number">12.</span> <span class="toc-text">十二.转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%B8%89-%E6%8E%A5%E5%8F%A3"><span class="toc-number">13.</span> <span class="toc-text">十三.接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B-this%E5%92%8Csuper%E4%B8%93%E9%A2%98"><span class="toc-number">14.</span> <span class="toc-text">十四.this和super专题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%BA%94-final%E4%B8%93%E9%A2%98"><span class="toc-number">15.</span> <span class="toc-text">十五.final专题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%85%AD-public-protect-default-private-static-final-abstract"><span class="toc-number">16.</span> <span class="toc-text">十六.public protect  default private static final abstract</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%B8%83-%E5%B8%B8%E7%94%A8api"><span class="toc-number">17.</span> <span class="toc-text">十七.常用api</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#object%E7%B1%BB"><span class="toc-number">17.1.</span> <span class="toc-text">object类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#objects%E7%B1%BB"><span class="toc-number">17.2.</span> <span class="toc-text">objects类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuilder%E7%B1%BB"><span class="toc-number">17.3.</span> <span class="toc-text">StringBuilder类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Date-%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="toc-number">17.4.</span> <span class="toc-text">Date 类概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SimpleDateFormat%E7%B1%BB"><span class="toc-number">17.5.</span> <span class="toc-text">SimpleDateFormat类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Calendar%E7%B1%BB"><span class="toc-number">17.6.</span> <span class="toc-text">Calendar类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">17.7.</span> <span class="toc-text">包装类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">17.8.</span> <span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arrays%E7%B1%BB"><span class="toc-number">17.9.</span> <span class="toc-text">Arrays类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%85%AB-%E9%9B%86%E5%90%88"><span class="toc-number">18.</span> <span class="toc-text">十八.集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Collection-API"><span class="toc-number">18.1.</span> <span class="toc-text">Collection API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">18.2.</span> <span class="toc-text">遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">18.2.1.</span> <span class="toc-text">方式一：迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9Aforeach-%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF"><span class="toc-number">18.2.2.</span> <span class="toc-text">方式二：foreach&#x2F;增强for循环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9Alambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">18.2.3.</span> <span class="toc-text">方式三：lambda表达式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List%E9%9B%86%E5%90%88"><span class="toc-number">18.3.</span> <span class="toc-text">List集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayList"><span class="toc-number">18.3.1.</span> <span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedList"><span class="toc-number">18.3.2.</span> <span class="toc-text">LinkedList</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">18.3.3.</span> <span class="toc-text">泛型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set%E9%9B%86%E5%90%88"><span class="toc-number">18.4.</span> <span class="toc-text">Set集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HashSet"><span class="toc-number">18.4.1.</span> <span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedHashSet"><span class="toc-number">18.4.2.</span> <span class="toc-text">LinkedHashSet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TreeSet"><span class="toc-number">18.4.3.</span> <span class="toc-text">TreeSet</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">18.5.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Collections-%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">18.6.</span> <span class="toc-text">Collections 集合工具类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MAP%E9%9B%86%E5%90%88"><span class="toc-number">18.7.</span> <span class="toc-text">MAP集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">18.7.1.</span> <span class="toc-text">HashMap的特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedHashMap%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">18.7.2.</span> <span class="toc-text">LinkedHashMap集合概述和特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TreeMap%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">18.7.3.</span> <span class="toc-text">TreeMap集合概述和特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%89%B9%E7%82%B9"><span class="toc-number">18.7.4.</span> <span class="toc-text">Map集合实现类特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88"><span class="toc-number">18.8.</span> <span class="toc-text">不可变集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Stream%E6%B5%81"><span class="toc-number">18.9.</span> <span class="toc-text">Stream流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Stream%E6%B5%81%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">18.9.1.</span> <span class="toc-text">Stream流的概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Stream%E6%B5%81%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-number">18.9.2.</span> <span class="toc-text">Stream流的获取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Stream%E6%B5%81%E7%9A%84%E5%B8%B8%E7%94%A8API-%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">18.9.3.</span> <span class="toc-text">Stream流的常用API(中间操作方法)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Stream%E6%B5%81%E7%9A%84%E5%B8%B8%E8%A7%81%E7%BB%88%E7%BB%93%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">18.9.4.</span> <span class="toc-text">Stream流的常见终结操作方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Stream%E6%B5%81%E7%9A%84%E6%94%B6%E9%9B%86%E6%93%8D%E4%BD%9C"><span class="toc-number">18.9.5.</span> <span class="toc-text">Stream流的收集操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%B9%9D-%E5%BC%82%E5%B8%B8"><span class="toc-number">19.</span> <span class="toc-text">十九.异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%A6%82%E8%BF%B0%E3%80%81%E4%BD%93%E7%B3%BB"><span class="toc-number">19.1.</span> <span class="toc-text">异常概述、体系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">19.2.</span> <span class="toc-text">常见运行时异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">19.3.</span> <span class="toc-text">常见编译时异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E9%BB%98%E8%AE%A4%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">19.4.</span> <span class="toc-text">异常的默认处理流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">19.5.</span> <span class="toc-text">编译时异常的处理机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">19.6.</span> <span class="toc-text">运行时异常的处理机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">19.7.</span> <span class="toc-text">自定义异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81-%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF"><span class="toc-number">20.</span> <span class="toc-text">二十.日志技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Logback%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6"><span class="toc-number">20.1.</span> <span class="toc-text">Logback日志框架</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%80-File%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">21.</span> <span class="toc-text">二十一.File类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAFile%E5%AF%B9%E8%B1%A1"><span class="toc-number">21.1.</span> <span class="toc-text">创建File对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">21.2.</span> <span class="toc-text">常用方法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%BA%8C-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="toc-number">22.</span> <span class="toc-text">二十二.字符编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ASCII%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">22.1.</span> <span class="toc-text">ASCII字符集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GBK%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">22.2.</span> <span class="toc-text">GBK字符集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unicode%EF%BC%88UTF-8%EF%BC%89"><span class="toc-number">22.3.</span> <span class="toc-text">Unicode（UTF-8）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%89-IO%E6%B5%81"><span class="toc-number">23.</span> <span class="toc-text">二十三.IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%9A"><span class="toc-number">23.1.</span> <span class="toc-text">字节输入流：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%9A"><span class="toc-number">23.2.</span> <span class="toc-text">字节输出流：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%9A"><span class="toc-number">23.3.</span> <span class="toc-text">字符输入流：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%9A"><span class="toc-number">23.4.</span> <span class="toc-text">字符输出流：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">23.5.</span> <span class="toc-text">缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E5%92%8C%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">23.5.1.</span> <span class="toc-text">字节输入和字节输出缓冲流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">23.5.2.</span> <span class="toc-text">字符输入缓冲流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">23.5.3.</span> <span class="toc-text">字符输出缓冲流</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">23.6.</span> <span class="toc-text">转换流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">23.6.1.</span> <span class="toc-text">字符输入转换流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">23.6.2.</span> <span class="toc-text">字符输出转换流</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">23.7.</span> <span class="toc-text">序列化对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9A"><span class="toc-number">23.7.1.</span> <span class="toc-text">对象序列化：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9A"><span class="toc-number">23.7.2.</span> <span class="toc-text">对象反序列化：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">23.8.</span> <span class="toc-text">打印流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">23.9.</span> <span class="toc-text">输出语句重定向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Properties"><span class="toc-number">23.10.</span> <span class="toc-text">Properties</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E6%A1%86%E6%9E%B6"><span class="toc-number">23.11.</span> <span class="toc-text">IO框架</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#commons-io"><span class="toc-number">23.11.1.</span> <span class="toc-text">commons-io</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E5%9B%9B-%E7%BA%BF%E7%A8%8B"><span class="toc-number">24.</span> <span class="toc-text">二十四.线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">24.1.</span> <span class="toc-text">多线程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-thread%E7%B1%BB"><span class="toc-number">24.1.1.</span> <span class="toc-text">1.thread类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">24.1.2.</span> <span class="toc-text">2.runnable接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Callable%E6%8E%A5%E5%8F%A3"><span class="toc-number">24.1.3.</span> <span class="toc-text">3.Callable接口</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%90%8C%E6%AD%A5"><span class="toc-number">24.2.</span> <span class="toc-text">线程安全和同步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">24.2.1.</span> <span class="toc-text">方式一：同步代码块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">24.2.2.</span> <span class="toc-text">方式二：同步方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9ALock%E9%94%81"><span class="toc-number">24.2.3.</span> <span class="toc-text">方式三：Lock锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">24.3.</span> <span class="toc-text">线程通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">24.4.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E8%BF%B0"><span class="toc-number">24.4.1.</span> <span class="toc-text">线程池概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E7%9A%84API%E3%80%81%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">24.4.2.</span> <span class="toc-text">线程池实现的API、参数说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">24.4.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Executors%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">24.4.4.</span> <span class="toc-text">Executors工具类实现线程池</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">24.5.</span> <span class="toc-text">定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9ATimer"><span class="toc-number">24.5.1.</span> <span class="toc-text">方式一：Timer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A-ScheduledExecutorService"><span class="toc-number">24.5.2.</span> <span class="toc-text">方式二： ScheduledExecutorService</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">24.6.</span> <span class="toc-text">线程的生命周期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">25.</span> <span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">25.1.</span> <span class="toc-text">网络通信三要素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E8%A6%81%E7%B4%A0%E6%A6%82%E8%BF%B0%E3%80%81%E8%A6%81%E7%B4%A0%E4%B8%80%EF%BC%9AIP%E5%9C%B0%E5%9D%80"><span class="toc-number">25.1.1.</span> <span class="toc-text">三要素概述、要素一：IP地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%B1%BB-InetAddress"><span class="toc-number">25.1.2.</span> <span class="toc-text">IP地址操作类-InetAddress</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A6%81%E7%B4%A0%E4%BA%8C%EF%BC%9A%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">25.1.3.</span> <span class="toc-text">要素二：端口号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A6%81%E7%B4%A0%E4%B8%89%EF%BC%9A%E5%8D%8F%E8%AE%AE"><span class="toc-number">25.1.4.</span> <span class="toc-text">要素三：协议</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP"><span class="toc-number">25.2.</span> <span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP"><span class="toc-number">25.3.</span> <span class="toc-text">TCP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">26.</span> <span class="toc-text">单元测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">27.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">28.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">29.</span> <span class="toc-text">动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XML"><span class="toc-number">30.</span> <span class="toc-text">XML</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XML%E6%96%87%E6%A1%A3%E7%BA%A6%E6%9D%9F%E6%96%B9%E5%BC%8F%E4%B8%80-DTD%E7%BA%A6%E6%9D%9F"><span class="toc-number">30.1.</span> <span class="toc-text">XML文档约束方式一-DTD约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XML%E6%96%87%E6%A1%A3%E7%BA%A6%E6%9D%9F%E6%96%B9%E5%BC%8F%E4%BA%8C-schema%E7%BA%A6%E6%9D%9F"><span class="toc-number">30.2.</span> <span class="toc-text">XML文档约束方式二-schema约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XML%E8%A7%A3%E6%9E%90%E6%8A%80%E6%9C%AF"><span class="toc-number">30.3.</span> <span class="toc-text">XML解析技术</span></a></li></ol></li></ol>
        </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>




</html>
